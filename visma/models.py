# this is auto-generated by swagger-marshmallow-codegen
from __future__ import annotations
from marshmallow import (
    Schema,
    fields,
    INCLUDE,
)
from marshmallow.validate import (
    Length,
    OneOf,
    Regexp,
)
from swagger_marshmallow_codegen.validate import Range
import re
from visma.base import VismaModel

import logging

logger = logging.getLogger(__name__)


class PaginatedResponse(VismaModel):
    """
    Represents the structure of paginated responses on all API endpoints that
    supports pagination.

    .. note::
       As of now this is overridden in model meta class.
       Had problem getting the attriutes to register on creation

    """
    meta = fields.Nested('PaginationMetadataSchema', data_key='Meta')


class AccountApi(Schema):
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    FiscalYearId = fields.UUID(required=True, description='Source: Get from /v2/fiscalyears. The Id of the Fiscal year that the account belongs to')
    IsActive = fields.Boolean(required=True, description='Purpose: If the account is active or not')
    IsBlockedForManualBooking = fields.Boolean(description='Purpose: If the account is blocked for manual bookkeeping. Automatic bookkeeping will always be available, no matter the setting on this property')
    IsCostCenterAllowed = fields.Boolean(description='Purpose: If the account is allowed to have cost centers connected to it')
    IsProjectAllowed = fields.Boolean(description='Purpose: If the account is allowed to have projects connected to it')
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Name = fields.String(required=True, description='Max length: 100 characters. The name of the account', validate=[Length(min=0, max=100, equal=None)])
    Number = fields.String(required=True, description='The account number')
    ReferenceCode = fields.String(description='Purpose: Returns the reference code on the account. This feature is for dutch companies only', dump_only=True)
    Type = fields.Integer(description='Purpose: Returns account type number. This feature is for dutch companies only', dump_only=True)
    TypeDescription = fields.String(description='Purpose: Returns account type descripion', dump_only=True)
    VatCodeDescription = fields.String(description='Purpose: Describes what kind of VAT that is associated with the account', dump_only=True)
    VatCodeId = fields.UUID(description='Source: Get from /v2/vatcodes. The Id of the VAT code that is associated with the account. Can be null if account does not have a vat code')

    class Meta:
        unknown = INCLUDE



class AccountBalanceAPI(Schema):
    AccountName = fields.String(description='Purpose: The account name', dump_only=True)
    AccountNumber = fields.Integer(description='Purpose: The account number', dump_only=True)
    AccountType = fields.Integer(description='Purpose: The account type number. For reports only', dump_only=True)
    AccountTypeDescription = fields.String(description='Purpose: The Account Type Description. For reports only. Unfilterable property, filter on AccountType instead', dump_only=True)
    Balance = fields.Number(description='Purpose: The total account balance at the given date', dump_only=True)

    class Meta:
        unknown = INCLUDE



class AccountOpeningBalanceApi(Schema):
    AccountNumber = fields.Integer()
    Balance = fields.Number()

    class Meta:
        unknown = INCLUDE



class AccountTypesAPI(Schema):
    Type = fields.Integer()
    TypeDescription = fields.String()

    class Meta:
        unknown = INCLUDE



class AccountingLockDateApi(Schema):
    Month = fields.Integer(description='Range: 1 - 12', validate=[Range(min=1, max=12, min_inclusive=True, max_inclusive=True)])
    Year = fields.Integer()

    class Meta:
        unknown = INCLUDE



class AccountingLockSettingsApi(Schema):
    AccountingLockInterval = fields.Integer(description='Range: 0 - 4. 0 = None, 1 = Month, 2 = Quarter, 3 = Year, 4 = TaxDeclaration', validate=[Range(min=0, max=4, min_inclusive=True, max_inclusive=True), OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    AccountingLockedAsOf = fields.Nested(lambda: AccountingLockDateApi())
    TaxDeclarationDate = fields.Nested(lambda: TaxDeclarationDateApi())

    class Meta:
        unknown = INCLUDE



class AllocationPeriodApi(Schema):
    AllocationPeriodSourceType = fields.Integer(description='0 = SupplierInvoice, 1 = ManualVoucher, 2 = CustomerInvoice, 3 = CustomerInvoiceDraft', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])
    Amount = fields.Number(dump_only=True)
    BookkeepingDate = fields.AwareDateTime()
    CostCenterItemId1 = fields.UUID()
    CostCenterItemId2 = fields.UUID()
    CostCenterItemId3 = fields.UUID()
    CreatedUtc = fields.AwareDateTime()
    CreditAccountNumber = fields.Integer(dump_only=True)
    CustomerInvoiceDraftId = fields.UUID(dump_only=True)
    CustomerInvoiceDraftRow = fields.Integer(dump_only=True)
    CustomerInvoiceId = fields.UUID(dump_only=True)
    CustomerInvoiceRow = fields.Integer(dump_only=True)
    DebitAccountNumber = fields.Integer(dump_only=True)
    Id = fields.UUID()
    IsCredit = fields.Boolean()
    ManualVoucherId = fields.UUID()
    ManualVoucherRow = fields.Integer()
    NonVatRows = fields.List(fields.Nested(lambda: AllocationPeriodRowApi()), dump_only=True)
    ProjectId = fields.UUID()
    Rows = fields.List(fields.Nested(lambda: AllocationPeriodRowApi()), required=True)
    Status = fields.Integer(description='0 = Pending, 1 = Revoked, 2 = Booked', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    SupplierInvoiceDraftId = fields.UUID()
    SupplierInvoiceDraftRow = fields.Integer()
    SupplierInvoiceId = fields.UUID()
    SupplierInvoiceRow = fields.Integer()
    VoucherFiscalYearId = fields.UUID(description='Returns the fiscal year id of the voucher coresponding to the source type', dump_only=True)
    VoucherId = fields.UUID(description='Source voucher id', dump_only=True)

    class Meta:
        unknown = INCLUDE



class AllocationPeriodRowApi(Schema):
    AccountNumber = fields.Integer(required=True)
    AllocationPeriodId = fields.UUID()
    AllocationPeriodRowType = fields.Integer(description='None = 0, InputVat = 1', validate=[OneOf(choices=[0, 1], labels=[])])
    Amount = fields.Number(required=True)
    DebitCredit = fields.Integer(required=True, description='1 = Debit, 2 = Credit', validate=[OneOf(choices=[1, 2], labels=[])])
    Id = fields.UUID()
    Quantity = fields.Number()
    Weight = fields.Number()

    class Meta:
        unknown = INCLUDE



class AllocationPlan(Schema):
    AllocationAccountNumber = fields.Integer(required=True, validate=[Range(min=0, max=9999, min_inclusive=True, max_inclusive=True)])
    AmountToAllocate = fields.Number(required=True, validate=[Range(min=1, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    BookkeepingStartDate = fields.AwareDateTime(required=True)
    NumberOfAllocationPeriods = fields.Integer(required=True, validate=[Range(min=1, max=9999, min_inclusive=True, max_inclusive=True)])
    QuantityToAllocate = fields.Number(description='Used for dutch companies that use agricultural settings', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    SupplierInvoiceDraftId = fields.UUID(description='If assigned, SupplierInvoiceDraftRow must be set')
    SupplierInvoiceDraftRow = fields.Integer(description='Required if SupplierInvoiceDraftId is assigned')
    SupplierInvoiceId = fields.UUID(description='If assigned, SupplierInvoiceRow must be set')
    SupplierInvoiceRow = fields.Integer(description='Required if SupplierInvoiceId is assigned')
    VoucherId = fields.UUID(description='If assigned, VoucherRow must be set')
    VoucherRow = fields.Integer(description='Required if VoucherId is assigned')
    WeightToAllocate = fields.Number(description='Used for dutch companies that use agricultural settings', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class AppStoreActivationStatusApi(Schema):
    ActivationStatus = fields.Integer(required=True, description='0 = Inactive, 1 = Active', validate=[OneOf(choices=[0, 1], labels=[])])
    Id = fields.UUID()
    ModifiedUtc = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class ApplyClause(Schema):
    Transformations = fields.List(fields.Nested(lambda: TransformationNode()), dump_only=True)

    class Meta:
        unknown = INCLUDE



class ApplyQueryOption(Schema):
    ApplyClause = fields.Nested(lambda: ApplyClause())
    Context = fields.Nested(lambda: ODataQueryContext())
    RawValue = fields.String(dump_only=True)
    ResultClrType = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class ApprovalApi(Schema):
    DocumentApprovalStatus = fields.Integer(required=True, description='1 = Approved, 2 = Rejected, 3 = ReadyForApproval', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])
    RejectionMessage = fields.String(description='Max length: 200 characters. Purpose: The message sent to users when rejecting a document. Empty if DocumentApprovalStatus is not 2 = Rejected', validate=[Length(min=0, max=200, equal=None)])
    RejectionMessageReceivers = fields.List(fields.UUID(), description='Purpose: The recipients of the rejection message. Empty if DocumentApprovalStatus is not 2 = Rejected. List of user ids. Use GET /v2/users')

    class Meta:
        unknown = INCLUDE



class ApprovalSettingsApi(Schema):
    UsesSupplierInvoiceApproval = fields.Boolean(description='Shows if the company has supplier invoice approval activated. Used with: /v2/approval/supplierinvoice/{id}', dump_only=True)
    UsesVatReportApproval = fields.Boolean(description='Shows if the company has vat report approval activated. Used with: /v2/approval/vatreport/{id}', dump_only=True)

    class Meta:
        unknown = INCLUDE



class ArticleAccountCodingAPI(Schema):
    ChangedUtc = fields.AwareDateTime(dump_only=True)
    DomesticSalesSubjectToReversedConstructionVatAccountNumber = fields.Integer()
    DomesticSalesSubjectToVatAccountNumber = fields.Integer()
    DomesticSalesVatCodeExemptAccountNumber = fields.Integer()
    DomesticSalesVatExemptAccountNumber = fields.Integer()
    ForeignSalesSubjectToMossAccountNumber = fields.Integer()
    ForeignSalesSubjectToThirdPartySalesAccountNumber = fields.Integer()
    ForeignSalesSubjectToVatWithinEuAccountNumber = fields.Integer()
    ForeignSalesVatExemptOutsideEuAccountNumber = fields.Integer()
    ForeignSalesVatExemptWithinEuAccountNumber = fields.Integer()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean()
    Name = fields.String()
    NameEnglish = fields.String()
    Type = fields.String()
    VatRate = fields.String()
    VatRatePercent = fields.Number()

    class Meta:
        unknown = INCLUDE



class ArticleApi(Schema):
    ArticleLabels = fields.List(fields.Nested(lambda: ArticleLabelApi()))
    Barcodes = fields.List(fields.Nested(lambda: ArticleBarcodeApi()), description='Article barcode (currently only one BarcodeType=Default)')
    ChangedUtc = fields.AwareDateTime(description='Purpose: Returns the last date and time from when a change was made on the article', dump_only=True)
    CodingId = fields.UUID(required=True, description='Source: Get from /v2/articleaccountcodings')
    CodingName = fields.String(dump_only=True)
    CreatedUtc = fields.AwareDateTime(description='Purpose: Returns the date and time when the article was created', dump_only=True)
    CurrencyCode = fields.String(description='The currency code for the purchase price', validate=[Length(min=0, max=3, equal=None)])
    DiscountPercentage = fields.Number(description='Discount from discount agreement')
    FreightCostWithCurrency = fields.Number(description="The article's freight cost expressed in the article's currency code")
    FreightCosts = fields.Number(description='Freight costs per article unit')
    FreightCostsManuallyChangedUtc = fields.AwareDateTime(description='Purpose: Set when the freight costs is changed manually', dump_only=True)
    GreenTechnologyType = fields.Integer(description='The type of green technology deduction that applies for this article.\r\n<list type="number"><listheader><term>Value</term><description>Usage</description></listheader><item><term>0</term><description>This article doesn\'t benefit from deduction applicable to green technology</description></item><item><term>1</term><description>Installation of solar cells and panels </description></item><item><term>2</term><description>Installation of systems for storing privately produced electricity</description></item><item><term>3</term><description>Installation of charging points for electric vehicles</description></item></list>')
    GrossPrice = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=10000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    HouseWorkType = fields.Integer(description='0 = None, 1 = RotConstructionWork , 2 = RotElectricalWork , 3 = RotGlassSheetMetalWork , 4 = RotGroundWork , 5 = RotBrickWork , 6 = RotPaintDecorateWork , 7 = RotPlumbWork \r\n9 = RutCleanJobWork , 10 = RutCareClothTextile , 11 = RutCook , 12 = RutSnowRemove , 13 = RutGarden , 14 = RutBabySitt , 15 = RutOtherCare , 17 = RutHouseWorkHelp   \r\n18 = RutRemovalServices , 19 = RutITServices , 20 = RotHeatPump , 21 = RotHeatPump2 , 22 = RutHomeAppliances, 23 = RotSolarHeatingSystem, 24 = RotWoodBoiler, 25 = RotFuelBoiler,\r\n26 = RutLaundry, 27 = RutFurnishing, 28 = RutGoodsTransport, 29 = RutHomeSupervision')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean(required=True)
    IsServiceArticle = fields.Boolean(description='IsServiceArticle = FALSE if the sales category for the article is of the type Goods\r\nIsServiceArticle = TRUE if the sales category for the article is of the type Service.\r\nTo be able to filter Articles by AccountCodingType, use property called CodingType: 1 = Goods, 2 = Services.', dump_only=True)
    IsStock = fields.Boolean(description='Article can be stock article if stock module is activated and sales category for the article Goods type')
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    Name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    NameEnglish = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    NetPrice = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=10000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    NetPriceWithDiscount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=10000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{noteId}', dump_only=True)
    Number = fields.String(required=True, description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    PurchasePrice = fields.Number(description='Purchase price of the article in domestic currency. When saved on the article this is rounded to 2 decimals.')
    PurchasePriceManuallyChangedUtc = fields.AwareDateTime(description='Purpose: Set when the purchase price is changed manually', dump_only=True)
    PurchasePriceWithCurrency = fields.Number(description="The purchase price expressed in the article's currency code")
    SendToWebshop = fields.Boolean(description='Purpose: If true, will send article to VismaWebShop (If company has the integration).\r\nDefault: True')
    ShowStockInformation = fields.Boolean(description="ShowStockInformation = TRUE IF company has active stock module, article is stock article and article is not a service article\r\n                            OR company hasn't active stock module and article is not a service article.", dump_only=True)
    StockBalance = fields.Number(description='Default: 0. \r\nPurpose: Sets the stock balance for this article\r\nWhen stock module is active, this is read only', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    StockBalanceAvailable = fields.Number(description='Purpose: Returns the available stock balance for this article', dump_only=True)
    StockBalanceManuallyChangedUtc = fields.AwareDateTime(description='Purpose: Set when the stock balance is changed manually', dump_only=True)
    StockBalanceReserved = fields.Number(description='Purpose: Returns the reserved stock balance for this article', dump_only=True)
    StockLocationReference = fields.String(description='Article stock location reference')
    StockValue = fields.Number(description='Total value of articles currently in stock', dump_only=True)
    UnitAbbreviation = fields.String(description='Purpose: Returns the unit abbreviation entered from UnitId', dump_only=True)
    UnitId = fields.UUID(required=True, description='Source: Get from /v2/units')
    UnitName = fields.String(description='Purpose: Returns the unit name entered from UnitId', dump_only=True)
    UpdateStockPrices = fields.Boolean(description='Purpose: Update article purchase price and freight costs when creating manual stock adjustment')
    UsesMoss = fields.Boolean(description='This property can be set if the OSS setting is checked in company settings. Only applicable if using Accrual accounting.')

    class Meta:
        unknown = INCLUDE



class ArticleBarcodeApi(Schema):
    Barcode = fields.String()
    BarcodeType = fields.Integer(validate=[OneOf(choices=[0], labels=[])])

    class Meta:
        unknown = INCLUDE



class ArticleLabelApi(Schema):
    Description = fields.String(description='Max length: 400 characters', validate=[Length(min=0, max=400, equal=None)])
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    Name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])

    class Meta:
        unknown = INCLUDE



class AttachmentLinkApi(Schema):
    AttachmentIds = fields.List(fields.UUID(), required=True)
    DocumentId = fields.UUID(description='The id inside eAccounting of the corresponding linked document. Source: Get from endpoints corresponding to your document type')
    DocumentType = fields.Integer(required=True, description='0 = None, 1 = SupplierInvoice, 2 = Receipt, 3 = Voucher, 4 = SupplierInvoiceDraft, 5 = AllocationPeriod, 6 = Transfer', validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 8], labels=[])])

    class Meta:
        unknown = INCLUDE



class AttachmentResultApi(Schema):
    AmountInvoiceCurrency = fields.Number()
    AttachedDocumentType = fields.Integer(description='0 = None, 1 = SupplierInvoice, 2 = Receipt, 3 = Voucher, 4 = SupplierInvoiceDraft, 5 = AllocationPeriod, 6 = Transfer', validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 8], labels=[])])
    AttachmentStatus = fields.Integer(description='0 = Matched, 1 = Unmatched', validate=[OneOf(choices=[0, 1], labels=[])])
    Comment = fields.String()
    ContentType = fields.String()
    CurrencyCode = fields.String()
    DocumentId = fields.UUID()
    FileName = fields.String()
    Id = fields.UUID(dump_only=True)
    ImageDate = fields.AwareDateTime(description='Date when source image was uploaded', dump_only=True)
    SupplierName = fields.String()
    TemporaryUrl = fields.String()
    TransactionDate = fields.AwareDateTime(description='The interpreted transaction date of the source image, eg invoicedate for a invoice, paymentdate for a reciept. \r\nCan be null if not interpreted.', dump_only=True)
    Type = fields.Integer(description='0 = Invoice, 1 = Receipt, 2 = Document', validate=[OneOf(choices=[0, 1, 2, 7], labels=[])])
    UploadedBy = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class AttachmentUploadApi(Schema):
    ContentType = fields.String(required=True, description="= ['image/jpeg' or 'image/png' or 'image/tiff' or 'application/pdf']", validate=[Length(min=0, max=15, equal=None)])
    Data = fields.String(description='Format: Must be Base64 encoded byte array.')
    FileName = fields.String(required=True)
    Id = fields.UUID()
    Url = fields.String(description='Must be public URL')

    class Meta:
        unknown = INCLUDE



class AutoInvoiceAddressApi(Schema):
    Address1 = fields.String()
    Address2 = fields.String()
    City = fields.String()
    CorporateIdentityNumber = fields.String()
    CountryCode = fields.String()
    EdiServiceDelivererId = fields.String()
    ElectronicAddress = fields.String()
    Gln = fields.String()
    Name = fields.String()
    PostalCode = fields.String()
    VatNumber = fields.String()

    class Meta:
        unknown = INCLUDE



class AutoInvoiceApi(Schema):
    AutoInvoiceActivationStatus = fields.Integer(description='0 = Unregistered, 1 = Registered, 2 = Activated', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    AutoInvoiceB2CStatus = fields.Integer(description='Only for Norway and Finland. 0 = NotActivated, 1 = Pending, 2 = Activated', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    AutoInvoiceInboundStatus = fields.Integer(description='0 = Deactivated, 1 = Activated', dump_only=True, validate=[OneOf(choices=[0, 1], labels=[])])

    class Meta:
        unknown = INCLUDE



class BalanceAndDateApi(Schema):
    Balance = fields.Number()
    Date = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class BankAccountApi(Schema):
    Balance = fields.Nested(lambda: BalanceAndDateApi())
    Bank = fields.UUID(description='Not required for dutch companies and bank accounts of cash or tax account type. Source: Get from /v2/banks')
    BankAccountHolderName = fields.String(description='Used for dutch companies')
    BankAccountType = fields.Integer(required=True, description='1 = ChequeAccount, 2 = CashAccount, 3 = SavingsAccount, 4 = CurrencyAccount, 5 = DigitalWalletAccount, 6 = CashCreditAccount, 7 = TaxAccount', validate=[OneOf(choices=[1, 2, 3, 4, 5, 6, 7, 8], labels=[])])
    BankAccountTypeDescription = fields.String(description='Purpose: Description of Bank Account type', dump_only=True)
    Bban = fields.String(description='Max length: 35 characters. Also known as Bank Account number. Not required for bank accounts of cash or tax account type', validate=[Length(min=0, max=35, equal=None)])
    CurrencyCode = fields.String(description='Purpose: Default value: Base currency of the company', dump_only=True)
    DirectDebitBatchBooking = fields.Boolean(description='Purpose: Indicates if batch booking is enabled for Direct debit.\r\nApplicable for NL only.\r\nThis property is ignored in PUT and POST operations.', dump_only=True)
    DirectDebitCreditorId = fields.String(description='Purpose: Creditor identifier from the direct debit contract.\r\nApplicable for NL only.\r\nThis property is ignored in PUT and POST operations.', dump_only=True)
    DirectDebitSendDirectlyToBank = fields.Boolean(description='Purpose: Indicates if automatic direct debit service is used.\r\nApplicable for NL only.\r\nThis property is ignored in PUT and POST operations.', dump_only=True)
    HasActiveBankAgreement = fields.Boolean()
    Iban = fields.String(description='Max length: 35 characters', validate=[Length(min=0, max=35, equal=None)])
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean()
    IsDefaultChequeAccount = fields.Boolean(description='Purpose: Only used when having several cheque accounts')
    IsEnabledDirectDebit = fields.Boolean(description='Purpose: Indicates if the bank account is used for direct debit.\r\nApplicable for NL only.\r\nThis property is ignored in PUT and POST operations.', dump_only=True)
    LedgerAccountNumber = fields.Integer(required=True, description='The general ledger account number')
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Name = fields.String(required=True, description='Max length: 200 characters', validate=[Length(min=0, max=200, equal=None)])

    class Meta:
        unknown = INCLUDE



class BankApi(Schema):
    Id = fields.UUID()
    Name = fields.String()

    class Meta:
        unknown = INCLUDE



class BankTransactionApi(Schema):
    ChargeAmount = fields.Number(description='The amount which represents bank charges')
    ChargeCurrency = fields.String(description='The currency of the bank charges amount')
    Id = fields.UUID()
    IsReconciled = fields.Boolean(description='True if the transaction has been matched')
    OriginalAmount = fields.Number(description='The amount which represents the original amount of the bank transaction')
    OriginalCurrency = fields.String(description='The currency corresponding to the original amount')
    Reference = fields.String(description='Represents the invoice reference of the bank transaction')
    Rows = fields.List(fields.Nested(lambda: BankTransactionRowApi()), description='Represents the accounting transactions related to the bank transaction')
    TransactionAmount = fields.Number(description='The total amount of the bank transaction, including bank charges')
    TransactionAmountCurrency = fields.String(description='The currency corresponding to the transaction amount')
    TransactionDate = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class BankTransactionRowApi(Schema):
    AmountTransactionCurrency = fields.Number()
    Name = fields.String(description='Depending on the Source property, displays information like invoice customer or supplier name, or document description')
    Number = fields.String(description='Depending on the Source property, it displays the number of the document associated to it')
    PaymentVoucherId = fields.UUID(description='Source: Get from /v2/vouchers')
    PaymentVoucherNumber = fields.String()
    Reference = fields.String(description='If the source is a customer or supplier invoice, it represents the OCR number of the specific invoice')
    Source = fields.String(description='The origin of the bank transaction')
    SourceId = fields.UUID(description='Represents the unique identifier of the Source property')
    VoucherId = fields.UUID(description='Source: Get from /v2/vouchers')

    class Meta:
        unknown = INCLUDE



class CompanyGreenTechnologySettingsApi(Schema):
    GreenTechnologyDeductionMaxAmount = fields.Number(description='Maximum deduction amount for Green Technology.', dump_only=True)
    SollarCellDiscountPercentage = fields.Number(description='Sollar Cell Discount Percentage.', dump_only=True)

    class Meta:
        unknown = INCLUDE



class CompanyRotRutSettingsApi(Schema):
    RotReducedInvoicingMaxAmount = fields.Number(validate=[Range(min=0, max=999999, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RotReducedInvoicingPercent = fields.Number(validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RutMaxAmountForPersBelow65Year = fields.Number(validate=[Range(min=0, max=999999, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RutMaxAmountForPersOver65Year = fields.Number(validate=[Range(min=0, max=999999, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RutReducedInvoicingPercent = fields.Number(validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class CompanySettings(VismaModel):
    AccountNumberDigits = fields.Integer(dump_only=True)
    AccountingLockInterval = fields.Integer(description='0 = None, 1 = Month, 2 = Quarter, 3 = Year, 4 = TaxDeclaration', dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    AccountingLockedTo = fields.AwareDateTime(dump_only=True)
    ActivatedModules = fields.List(fields.String(), dump_only=True)
    Address1 = fields.String(required=True, description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    Address2 = fields.String(description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    ApprovalSettings = fields.Nested(lambda: ApprovalSettingsApi())
    AutoInvoice = fields.Nested(lambda: AutoInvoiceApi())
    BankAccount = fields.String(dump_only=True)
    BankGiro = fields.String(description='Only used in Sweden.')
    BankgiroNumberPrint = fields.String(description='Alternative bank giro number on sales invoice printouts')
    City = fields.String(required=True, description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    CompanyGreenTechnologySettings = fields.Nested(lambda: CompanyGreenTechnologySettingsApi())
    CompanyIdentifier = fields.String(description='Company Identifier. Unique identifier for the company', dump_only=True)
    CompanyRotRutSettings = fields.Nested(lambda: CompanyRotRutSettingsApi())
    CompanyStatus = fields.Integer(description='0 = Inactive, Active = 1, ReadOnly = 2', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    CompanyText = fields.Nested(lambda: CompanyTextsApi())
    CorporateIdentityNumber = fields.String(dump_only=True)
    CountryCode = fields.String(required=True, description='Max length: 2 characters', validate=[Length(min=0, max=2, equal=None)])
    CurrencyCode = fields.String(dump_only=True)
    DomesticCurrencyRounding = fields.Integer(description='0 = None, HalfAwayFromZero = 1', dump_only=True, validate=[OneOf(choices=[0, 1], labels=[])])
    Email = fields.String(description='Max length: 255 characters', validate=[Length(min=0, max=255, equal=None)])
    Gln = fields.String(description='Global Location Number', dump_only=True)
    HasProportionalVatEnabled = fields.Boolean(dump_only=True)
    Iban = fields.String(dump_only=True)
    IsPayslipActivated = fields.Boolean(dump_only=True)
    KeepOriginalDraftDate = fields.Boolean(description='When set to true, keep the original sales invoice draft date as invoice date')
    MobilePhone = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    Name = fields.String(required=True, description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    NextArticleNumber = fields.Integer(dump_only=True)
    NextCustomerInvoiceNumber = fields.Integer(dump_only=True)
    NextCustomerNumber = fields.Integer(dump_only=True)
    NextOrderNumber = fields.Integer(dump_only=True)
    NextQuoteNumber = fields.Integer(dump_only=True)
    NextSupplierNumber = fields.Integer(dump_only=True)
    OurReference = fields.String(description='Default company reference.\r\nMax length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    PeppolId = fields.String(description='PeppolParticipantIdentifiers string separated by semicolons.\r\nIf identifier is empty in DB the we try to fetch it from InExchange.', dump_only=True)
    Phone = fields.String(required=True, description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    PlusGiro = fields.String(description='Only used in Sweden.')
    PostalCode = fields.String(required=True, description='Max length: 10 characters', validate=[Length(min=0, max=10, equal=None)])
    ProductVariant = fields.Integer(description='Variant of eAccouting. 1 = Standard/Smart, 2 = Invoicing, 3 = Bookkeeping, 4 = Start/Solo, 5 = Pro, 6 = InvoicingCollaboration', dump_only=True, validate=[OneOf(choices=[1, 2, 3, 4, 5, 6], labels=[])])
    ProportionalVatValue = fields.Integer(dump_only=True)
    ShowContributionMargin = fields.Boolean(dump_only=True)
    ShowCostCenterReminder = fields.Boolean(description='Customer has opted to get reminded about adding a cost center when creating invoices.', dump_only=True)
    ShowPricesExclVatPC = fields.Boolean(description='Show prices excluding VAT for private individuals', dump_only=True)
    ShowProjectReminder = fields.Boolean(description='Customer has opted to get reminded about adding a project when creating invoices.', dump_only=True)
    TaxDeclarationDate = fields.Nested(lambda: TaxDeclarationDateApi())
    TermsOfPaymentId = fields.UUID(description='Source: Get from /v2/termsofpayments', dump_only=True)
    TypeOfBusiness = fields.Integer(description='1 = Corporation, 2 = SoleProprietorship, 3 = EconomicAssociation, 4 = NonProfitOrganization, 5 = GeneralPartnership, 6 = LimitedPartnership, 7 = Cooperatives, 9 = PublicLimited', dump_only=True, validate=[OneOf(choices=[1, 2, 3, 4, 5, 6, 7, 9], labels=[])])
    UseAutomaticVatCalculation = fields.Boolean(description='When set to true, vat rows are added (when creating a voucher for example), if the account used relates to.\r\nUsed for SE, NO, FI')
    UsePaymentFilesForOutgoingPayments = fields.Boolean(description='When set to true, supplier invoices can be exported as paymentfile and manually sent to bank')
    UsesCostCenter = fields.Boolean(dump_only=True)
    UsesGreenTechnology = fields.Boolean(description='Customer has opted to use Green Technology.', dump_only=True)
    UsesMoss = fields.Boolean()
    UsesPaymentReferenceNumber = fields.Boolean(description='Show OCR/KID reference no. on invoice')
    UsesProject = fields.Boolean(dump_only=True)
    UsesReverseConstructionVat = fields.Boolean(description='Construction sector, VAT reverse charge rules apply')
    UsesRotReducedInvoicing = fields.Boolean(description='Only for swedish companies. Domestic services to private individuals, ROT/RUT rules apply')
    UsesVatTriangulationRules = fields.Boolean(description='When set to true, EU triangular transactions involve three parties and direct goods shipping, with the end VAT-registered customer liable for VAT.')
    VatCode = fields.String(description='VAT identification number', dump_only=True)
    VatPeriod = fields.Integer(description='Period when VAT report should be sent. 1 = OnceAMonth12th, 2 = OnceAMonth26th, 3 = OnceAQuarter, 4 = OnceAYear, 5 = Never, 6 = Bimonthly, 7 = OnceAMonth, 8 = TwiceAYear, 9 = OnceAQuarterFloating', dump_only=True, validate=[OneOf(choices=[1, 2, 3, 4, 5, 6, 7, 8, 9], labels=[])])
    Website = fields.String(description='Max length: 255 characters', validate=[Length(min=0, max=255, equal=None)])

    class Meta:
        endpoint = '/companysettings'
        allowed_methods = ['list', 'update']



class CompanyTextsApi(Schema):
    CustomerInvoiceTextDomestic = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    CustomerInvoiceTextForeign = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    InvoiceEmailDomestic = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    InvoiceEmailForeign = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    OrderEmailDomestic = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    OrderEmailForeign = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    OrderTextDomestic = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    OrderTextForeign = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    OverDueTextDomestic = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    OverDueTextForeign = fields.String(description='Max length: 180 characters', validate=[Length(min=0, max=180, equal=None)])
    PurchaseOrderEmailDomestic = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    PurchaseOrderEmailForeign = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    QuoteEmailDomestic = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])
    QuoteEmailForeign = fields.String(description='Max length: 2048 characters', validate=[Length(min=0, max=2048, equal=None)])

    class Meta:
        unknown = INCLUDE



class ContributionMarginApi(Schema):
    Amount = fields.Number(description='Amount of contribution margin')
    Percentage = fields.Number(description='Percentage of contribution margin')

    class Meta:
        unknown = INCLUDE



class CostCenterApi(Schema):
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean()
    Items = fields.List(fields.Nested(lambda: CostCenterItemApi()), description='The cost center items associated to this cost center')
    Name = fields.String(required=True, validate=[Length(min=0, max=20, equal=None)])
    Number = fields.Integer(description='Purpose: The number of the cost center generated by eAccounting', dump_only=True)

    class Meta:
        unknown = INCLUDE



class CostCenterItemApi(Schema):
    CostCenterId = fields.UUID(required=True, description='Source: Get from /v2/costcenters')
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean(required=True)
    Name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    ShortName = fields.String(required=True, description='Max length: 9 characters', validate=[Length(min=0, max=9, equal=None)])

    class Meta:
        unknown = INCLUDE



class CountQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    RawValue = fields.String(dump_only=True)
    Validator = fields.Nested(lambda: CountQueryValidator())
    Value = fields.Boolean(dump_only=True)

    class Meta:
        unknown = INCLUDE



class CountQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class CountryApi(Schema):
    Code = fields.String()
    IsEuMember = fields.Boolean()
    Name = fields.String()

    class Meta:
        unknown = INCLUDE



class CreditedByApi(Schema):
    CreditInvoiceId = fields.UUID(description='The Id of the customer invoice')

    class Meta:
        unknown = INCLUDE



class CurrencyApi(Schema):
    Code = fields.String()

    class Meta:
        unknown = INCLUDE



class Customer(VismaModel):
    AutoInvoiceActivationEmailSentDate = fields.AwareDateTime(allow_none=True)
    AutoInvoiceRegistrationRequestSentDate = fields.AwareDateTime(allow_none=True)
    ChangedUtc = fields.AwareDateTime(description='Purpose: Returns the last date and time from when a change was made on the customer', load_only=True, allow_none=True)
    ContactPersonEmail = fields.String(description='Max length: 255 characters', validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    ContactPersonMobile = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    ContactPersonName = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)], allow_none=True)
    ContactPersonPhone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    CorporateIdentityNumber = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)], allow_none=True)
    CurrencyCode = fields.String(description='Max length: 3 characters. Default value: Currency of the user company', validate=[Length(min=0, max=3, equal=None)], allow_none=True)
    CustomerLabels = fields.List(fields.Nested(lambda: CustomerLabelApi()), allow_none=True)
    CustomerNumber = fields.String(description='Max length: 16 characters. Purpose: Unique identifier. If not provided, eAccounting will provide one', validate=[Length(min=0, max=16, equal=None)], allow_none=True)
    DeliveryAddress1 = fields.String(description='Max length: 50 characters. Purpose: Only used if invoice address differs from delivery address', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    DeliveryAddress2 = fields.String(description='Max length: 50 characters. Purpose: Only used if invoice address differs from delivery address', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    DeliveryBasedVat = fields.Boolean(description='Purpose: Option to set the delivery address as the base for vat and oss calculations. Delivery city, country code and postal code must be set as well', default=False)
    DeliveryCity = fields.String(description='Max length: 50 characters. Purpose: Only used if invoice city differs from delivery city', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    DeliveryCountryCode = fields.String(description='Max length: 2 characters. Purpose: Only used if invoice country code differs from delivery country code', validate=[Length(min=0, max=2, equal=None)], allow_none=True)
    DeliveryCustomerName = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)], allow_none=True)
    DeliveryMethodId = fields.UUID(description='Source: Get from /v2/deliverymethods', allow_none=True)
    DeliveryPostalCode = fields.String(description='Max length: 10 characters. If DeliveryBasedVat is set to true this should be filled in as well', validate=[Length(min=0, max=10, equal=None)], allow_none=True)
    DeliveryTermId = fields.UUID(description='Source: Get from /v2/deliveryterms', allow_none=True)
    DirectDebitCustomerSettings = fields.Nested(lambda: DirectDebitCustomerSettingsApi(), allow_none=True)
    DiscountAgreementId = fields.UUID(description='Returns the discount agreement id that is connected to the customer. It will be used only for Pro variant companies', allow_none=True)
    DiscountPercentage = fields.Number(description='Format: 4 decimals',
                                       validate=[Range(min=0, max=1, min_inclusive=True,max_inclusive=True),
                                                 # Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))
                                                 ],
                                       default=0
                                       )
    EdiGlnNumber = fields.String(validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    EdiServiceDelivererId = fields.String(validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    ElectronicAddress = fields.String(validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    ElectronicReference = fields.String(validate=[Length(min=0, max=35, equal=None)], allow_none=True)
    EmailAddress = fields.String(description='Max length: 255 characters\r\nThis is a default email address for sending customer invoices.\r\nIf EmailAddressOrder and EmailAddressQuote properties are empty we use this email as default one for sending quotes and orders.', validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    EmailAddressOrder = fields.String(description='Max length: 255 characters\r\nThis is a default email address for sending orders.\r\nIf it is empty then we use general EmailAddress property.', validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    EmailAddressQuote = fields.String(description='Max length: 255 characters\r\nThis is a default email address for sending quotes.\r\nIf it is empty then we use general EmailAddress property.', validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    EmailAddresses = fields.List(fields.String(), allow_none=True)
    ForceBookkeepVat = fields.Boolean(default=True, allow_none=True)
    GLN = fields.String(description='NOTE: Obsolete. Please use EdiGlnNumber instead', validate=[Length(min=0, max=255, equal=None)], allow_none=True)
    Iban = fields.String(description="Max length: 35 characters\r\nDefault value: existing database value (PUT) or empty string (POST)\r\nPurpose: Customer's bank account IBAN (manual entry)", validate=[Length(min=0, max=35, equal=None)], allow_none=True)
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', load_only=True, allow_none=True)
    InvoiceAddress1 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    InvoiceAddress2 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    invoice_city = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True, data_key='InvoiceCity')
    InvoiceCountryCode = fields.String(description='Max length: 2 characters. When setting a VAT number this should be filled in as well.', validate=[Length(min=0, max=2, equal=None)], allow_none=True)
    invoice_postal_code = fields.String(required=True, description='Max length: 10 characters', validate=[Length(min=0, max=10, equal=None)], allow_none=True, data_key="InvoicePostalCode")
    is_active = fields.Boolean(required=True, allow_none=True, data_key="IsActive")
    IsDirectDebitEnabled = fields.Boolean(description='Purpose: Setting for Direct Debit payments', allow_none=True)
    IsFutureInvoiceDateAllowed = fields.Boolean(description='Purpose: Future dates on invoices are allowed based on terms of payments and invoice currency code settings', load_only=True)
    IsNorthernIreland = fields.Boolean(allow_none=True)
    is_private_person = fields.Boolean(required=True, allow_none=True, data_key="IsPrivatePerson")
    LastInvoiceDate = fields.AwareDateTime(description='Purpose: Returns the last invoice date', load_only=True, allow_none=True)
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', load_only=True, allow_none=True)
    MobilePhone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True, data_key="Name")
    Note = fields.String(description='Max length: 4000 characters', validate=[Length(min=0, max=4000, equal=None)], allow_none=True)
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{noteId}', load_only=True, allow_none=True)
    PayToAccountId = fields.UUID(description='Purpose: The account Id on which payments are registered', load_only=True)
    ReverseChargeOnConstructionServices = fields.Boolean(description='Default: false. Purpose: If true, VatNumber must be set aswell', allow_none=True, load_only=True)
    SalesDocumentLanguage = fields.String(description='Max length: 2 characters', validate=[Length(min=0, max=2, equal=None)], allow_none=True)
    SalesPriceListId = fields.UUID(description='Returns the sales price list id that is connected to the customer. It will be used only for Pro variant companies', allow_none=True)
    Telephone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)], allow_none=True)
    terms_of_payment_id = fields.UUID(required=True, description='Source: Get from /v2/termsofpayment', data_key="TermsOfPaymentId")
    TermsOfPayment = fields.Nested(lambda: TermsOfPayment(), allow_none=True)
    UnpaidInvoicesAmount = fields.Number(description='The total amount of unpaid invoices for the customer.', load_only=True, allow_none=True, default=0, required=True)
    VatNumber = fields.String(description='Max length: 20 characters. Format: 2 character country code followed by 8-12 numbers.', validate=[Length(min=0, max=20, equal=None)], allow_none=True)
    WebshopCustomerNumber = fields.Integer(allow_none=True)
    WwwAddress = fields.String(description='Max length: 255 characters', validate=[Length(min=0, max=255, equal=None)], allow_none=True)

    class Meta:
        endpoint = '/customers'
        allowed_methods = ['list', 'get', 'create', 'update', 'delete']
        envelope_class = PaginatedResponse
        envelopes = {'list': {'class': PaginatedResponse, 'data_attr': 'Data'}}




class CustomerInvoiceApi(Schema):
    BuyersOrderReference = fields.String(description='Purpose: Used when sending electronic invoices. Max length: 35 characters. Can be null or empty', validate=[Length(min=0, max=35, equal=None)])
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CreatedByUserId = fields.UUID(dump_only=True)
    CreatedFromDraftId = fields.UUID(description='If a valid customer invoice draft Id is provided, it will be bookkeeped using the option entered in the SentType property')
    CreatedFromOrderId = fields.UUID(dump_only=True)
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CreditedBy = fields.List(fields.Nested(lambda: CreditedByApi()), description='Credit customer invoices created based on the customer invoice\r\nOnly applicable when IsCreditInvoice is false', dump_only=True)
    CurrencyCode = fields.String(dump_only=True)
    CurrencyRate = fields.Number(description='Default: Automatic calculation of the currency rate. Enter this value to provide a custom rate')
    CustomerEmail = fields.String(dump_only=True)
    CustomerId = fields.UUID(required=True)
    CustomerIsPrivatePerson = fields.Boolean(dump_only=True)
    CustomerName = fields.String(dump_only=True)
    CustomerNumber = fields.String(dump_only=True)
    DeliveryAddress1 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DeliveryAddress2 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCity = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCountryCode = fields.String(description='Max length: 2 characters', validate=[Length(min=0, max=2, equal=None)])
    DeliveryCustomerName = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    DeliveryDate = fields.AwareDateTime()
    DeliveryMethodCode = fields.String(dump_only=True)
    DeliveryMethodName = fields.String(dump_only=True)
    DeliveryPostalCode = fields.String(description='Max length: 10 characters', validate=[Length(min=0, max=10, equal=None)])
    DeliveryTermCode = fields.String(dump_only=True)
    DeliveryTermName = fields.String(dump_only=True)
    DueDate = fields.AwareDateTime()
    EdiServiceDelivererId = fields.String(validate=[Length(min=0, max=50, equal=None)])
    ElectronicAddress = fields.String(dump_only=True)
    ElectronicReference = fields.String()
    EuThirdParty = fields.Boolean(required=True, description='Default: false. True only if EU intermediary, VAT triangulation rules apply.\r\nOnly if EU company is invoicing to a company from a different EU country, may set to True if desired.')
    FactoringInvoiceStatus = fields.Integer(description='Describes the sold invoice status in factoring partner system.\r\n0 - Unknown\r\n1 - Applied(applies for soft offers)\r\n2 - Withdrawn(applies for soft offers)\r\n3 - Rejected(applies for soft offers)\r\n4 - Sold\r\n5 - Approved(applies for soft offers)\r\n6 - FirstReminderSent\r\n7 - DebtCollection\r\n8 - Reclaimed\r\n9 - FullyPaid\r\n10 - Closed\r\n11 - SecondReminderSent', dump_only=True, validate=[OneOf(choices=[0, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13], labels=[])])
    HasAutoInvoiceError = fields.Boolean(dump_only=True)
    Id = fields.UUID(description='Purpose: This is automatically generated by eAccounting upon creation', dump_only=True)
    IncludesVat = fields.Boolean(description='Purpose: If true the unit prices on rows include VAT. The value is set upon creation depending whether "Show prices excl. VAT for private individuals" in company settings is marked or not', dump_only=True)
    InvoiceAddress1 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    InvoiceAddress2 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    InvoiceCity = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    InvoiceCountryCode = fields.String(description='Max length: 2 characters', validate=[Length(min=0, max=2, equal=None)])
    InvoiceCustomerName = fields.String(dump_only=True)
    InvoiceDate = fields.AwareDateTime()
    InvoiceNumber = fields.Integer(dump_only=True)
    InvoicePostalCode = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    IsCreditInvoice = fields.Boolean()
    IsDirectDebit = fields.Boolean(description='Indicated whether this invoice has direct debit applied\r\nOnly applicable for NL', dump_only=True)
    IsNotDelivered = fields.Boolean(description='Purpose: True if sending by email has failed', dump_only=True)
    IsSold = fields.Boolean(description='Defines whether customer invoice was sold using an integration with factoring partner', dump_only=True)
    MaxAllowedTaxReductionAmount = fields.Number(description='Default: maximum allowed tax reduction amount.', dump_only=True)
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{noteId}', dump_only=True)
    OurReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    PaymentDate = fields.AwareDateTime(dump_only=True)
    PaymentReferenceNumber = fields.String(description='Purpose: Empty if UsesPaymentReferenceNumber not activated on the company. Use /v2/companysettings.', dump_only=True)
    PaymentReminderIssued = fields.Boolean(description='Purpose: If true a payment reminder has been sent for the overdue invoice, otherwise it will be set as false. To send a payment reminder please use the v2/customerinvoices/{invoiceId}/paymentreminders endpoint', dump_only=True)
    PaymentStatus = fields.Integer(description='0 = Paid, 1 = Unpaid, 2 = Overdue', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    Persons = fields.List(fields.Nested(lambda: SalesDocumentRotRutReductionPersonApi()), description='Purpose: Required for ROT, RUT or Green Technology invoices only')
    ReferringInvoiceId = fields.UUID(dump_only=True)
    RemainingAmount = fields.Number(dump_only=True)
    RemainingAmountInvoiceCurrency = fields.Number(dump_only=True)
    ReverseChargeOnConstructionServices = fields.Boolean(dump_only=True)
    ReversedConstructionVatInvoicing = fields.Boolean(dump_only=True)
    RotPropertyType = fields.Integer(description='1 = Apartment, 2 = Property\r\nLeave blank or set to null if you do not intend to use ROT or Green Technology functionality', validate=[Range(min=1, max=2, min_inclusive=True, max_inclusive=True)])
    RotReducedInvoicingAmount = fields.Number(description='Default: Automatic tax reduction calculation. Used for the manual input of the deducted tax reduction', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RotReducedInvoicingAutomaticDistribution = fields.Boolean(dump_only=True)
    RotReducedInvoicingOrgNumber = fields.String(validate=[Length(min=0, max=11, equal=None)])
    RotReducedInvoicingPercent = fields.Number(description='Format: 4 decimals', dump_only=True)
    RotReducedInvoicingPropertyName = fields.String(description='Used for providing a custom name. Is required when RotPropertyType or UsesGreenTechnology is set.')
    RotReducedInvoicingType = fields.Integer(required=True, description='0 = Normal, 1 = Rot, 2 = Rut', validate=[Range(min=0, max=2, min_inclusive=True, max_inclusive=True), OneOf(choices=[0, 1, 2], labels=[])])
    Rows = fields.List(fields.Nested(lambda: CustomerInvoiceRowApi()), required=True)
    SalesDocumentAttachments = fields.List(fields.UUID(), description='Upload attachments via POST /v2/salesdocumentattachments/customerinvoice', dump_only=True)
    SendType = fields.Integer(description='Used for sending the invoice via Autoinvoice\r\nDefault:None\r\n0 = None, 1 = AutoInvoiceElectronic, 2 = AutoInvoicePrint, 3 = AutoInvoiceB2C', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])
    SetOffAmountInvoiceCurrency = fields.Number(dump_only=True)
    TermsOfPaymentId = fields.UUID(description="Specify a different terms of payment for the invoice. If not filled customer's terms of payment will be used")
    TotalAmount = fields.Number(dump_only=True)
    TotalAmountInvoiceCurrency = fields.Number(dump_only=True)
    TotalRoundings = fields.Number(dump_only=True)
    TotalVatAmount = fields.Number(dump_only=True)
    TotalVatAmountInvoiceCurrency = fields.Number(dump_only=True)
    UsesGreenTechnology = fields.Boolean(description='Set to true if this customer invoice benefits from deduction on Green Technology.\r\nIf set to true the customer invoice must have RotReducedInvoicingType set to normal and contain at least one row with applicable deduction.')
    VatSpecification = fields.List(fields.Nested(lambda: CustomerInvoiceVatApi()), description='Purpose: A summary of amounts for each VAT rate', dump_only=True)
    VoucherId = fields.UUID(dump_only=True)
    VoucherNumber = fields.String(dump_only=True)
    WorkHouseOtherCosts = fields.Number()
    YourReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceDraft(VismaModel):
    BuyersOrderReference = fields.String(description='Purpose: Used when sending electronic invoices. Max length: 35 characters. Can be null or empty', validate=[Length(min=0, max=35, equal=None)])
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CreatedUtc = fields.AwareDateTime(description='Purpose: Is automatically set', dump_only=True)
    CustomerId = fields.UUID(required=True, description='Source: Get from /v2/customers')
    CustomerIsPrivatePerson = fields.Boolean(description="Purpose: Value is automatically set up depending on the selected customer's properties", dump_only=True)
    CustomerName = fields.String(description="Customer's actual name", dump_only=True)
    CustomerNumber = fields.String(description='Max length: 16 characters', dump_only=True, validate=[Length(min=0, max=16, equal=None)])
    DeliveryAddress1 = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryAddress2 = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCity = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCountryCode = fields.String(description='Max length: 2 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=2, equal=None)])
    DeliveryCustomerName = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryDate = fields.AwareDateTime()
    DeliveryMethodCode = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    DeliveryMethodName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DeliveryPostalCode = fields.String(description='Max length: 10 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=10, equal=None)])
    DeliveryTermCode = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    DeliveryTermName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DueDate = fields.AwareDateTime(description='Due date of the customer invoice draft.')
    ElectronicReference = fields.String(description='Set this if you later intend to send the invoice electronically. Can only be set for non-private individuals', validate=[Length(min=0, max=100, equal=None)])
    EuThirdParty = fields.Boolean(required=True)
    HouseWorkOtherCosts = fields.Number()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IncludesVat = fields.Boolean(description='Purpose: If true the unit prices on rows include VAT. The value is set upon creation depending whether "Show prices excl. VAT for private individuals" in company settings is marked or not', dump_only=True)
    InvoiceAddress1 = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    InvoiceAddress2 = fields.String(description='Max length: 50 characters\r\nSet a value if you want to override the existing property value taken from the customer', validate=[Length(min=0, max=50, equal=None)])
    InvoiceCity = fields.String(description="Purpose: Value is automatically set up depending on the selected customer's properties", dump_only=True, validate=[Length(min=0, max=50, equal=None)])
    InvoiceCountryCode = fields.String(description="Purpose: Value is automatically set up depending on the selected customer's properties", dump_only=True, validate=[Length(min=0, max=2, equal=None)])
    InvoiceCurrencyCode = fields.String(dump_only=True)
    InvoiceCustomerName = fields.String(description="Purpose: Value is automatically set up depending on the selected customer's properties", dump_only=True, validate=[Length(min=0, max=50, equal=None)])
    InvoiceDate = fields.AwareDateTime(description='Optional invoice date.')
    InvoicePostalCode = fields.String(description="Purpose: Value is automatically set up depending on the selected customer's properties", dump_only=True, validate=[Length(min=0, max=10, equal=None)])
    IsCreditInvoice = fields.Boolean()
    IsDirectDebit = fields.Boolean(description='Indicated whether this invoice has direct debit applied\r\nOnly applicable for NL', dump_only=True)
    MaxAllowedTaxReductionAmount = fields.Number(description='Default: maximum allowed tax reduction amount.', dump_only=True)
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{noteId}', dump_only=True)
    OurReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    Persons = fields.List(fields.Nested(lambda: SalesDocumentRotRutReductionPersonApi()))
    ReplaceUnitPriceWhenZero = fields.Boolean(description='When set to true an unit price of zero will be replaced with the unit price on the article register. When set to false it allows creation of drafts with unit price 0 on one or more rows.\r\nRows with an unit price other than 0 are not affected by this setting. The default value is false.')
    ReverseChargeOnConstructionServices = fields.Boolean(dump_only=True)
    RotPropertyType = fields.Integer(description='1 - Apartment\r\n2 - Property\r\nLeave blank or set to null if you do not intend to use ROT or Green Technology functionality')
    RotReducedInvoicingAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    RotReducedInvoicingAutomaticDistribution = fields.Boolean(description='Default: False')
    RotReducedInvoicingOrgNumber = fields.String(description='Max length: 11 characters', validate=[Length(min=0, max=11, equal=None)])
    RotReducedInvoicingPropertyName = fields.String(description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    RotReducedInvoicingType = fields.Integer(required=True, description='0 = Normal, 1 = Rot, 2 = Rut', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    Rows = fields.List(fields.Nested(lambda: CustomerInvoiceDraftRowApi()))
    SalesDocumentAttachments = fields.List(fields.UUID(), dump_only=True)
    TotalAmount = fields.Number(dump_only=True)
    TotalAmountBaseCurrency = fields.Number(dump_only=True)
    TotalRoundings = fields.Number(dump_only=True)
    TotalVatAmount = fields.Number(dump_only=True)
    TotalVatAmountBaseCurrency = fields.Number(dump_only=True)
    UsesGreenTechnology = fields.Boolean(description='Set to true if this customer invoice draft benefits from deduction on Green Technology.\r\nIf set to true the customer invoice draft must have RotReducedInvoicingType set to normal and contain at least one row with applicable deduction.')
    YourReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceDraftRowApi(Schema):
    ArticleId = fields.UUID(description='Source: Get from /v2/articles. Required if IsTextRow is false')
    ArticleNumber = fields.String(description='Purpose: Returns the article number from the entered ArticleId')
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenteritems')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenteritems')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenteritems')
    DiscountPercentage = fields.Number(description='Format: 4 decimals allowed', validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    GreenTechnologyType = fields.Integer(description='Type of green technology on the quote row, can be : \r\nNone = 0,\r\nSolarCellInstallation = 1,\r\nElectricEnergyStorageInstallation = 2,\r\nElectricVehicleChargingPointInstallation = 3,\r\nDefault value is 0.', validate=[Range(min=0, max=3, min_inclusive=True, max_inclusive=True)])
    Id = fields.UUID(description='Purpose: This property will be updated on every change on the customer invoice draft', dump_only=True)
    IsServiceArticle = fields.Boolean(description='IsServiceArticle = FALSE if the sales category for the article is of the type Goods\r\nIsServiceArticle = TRUE if the sales category for the article is of the type Service.', dump_only=True)
    IsTextRow = fields.Boolean(required=True)
    IsWorkCost = fields.Boolean()
    LineNumber = fields.Integer(description='Default: Automatic calculation based on the order of the row in the JSON.', validate=[Range(min=0, max=1000, min_inclusive=True, max_inclusive=True)])
    MaterialCosts = fields.Number()
    ProjectId = fields.UUID()
    Quantity = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    ReversedConstructionServicesVatFree = fields.Boolean(required=True)
    Text = fields.String(description="Max length: 2000 characters.\r\nDefault: For non text rows, default value will be the article's name; for text rows, there should be at least one character in place", validate=[Length(min=0, max=2000, equal=None)])
    UnitAbbreviation = fields.String()
    UnitAbbreviationEnglish = fields.String(description='Unit Abbrevation in English')
    UnitId = fields.UUID(description='Source: Get from /v2/units/{id}', dump_only=True)
    UnitName = fields.String()
    UnitPrice = fields.Number(description='Format: 2 decimals allowed if the customer is domestic or 4 decimals if foreign.\r\nThe default behavior when unit price is zero is specified by setting ReplaceUnitPriceWhenZero on the customer invoice draft.')
    VatRate = fields.Number(description='Default: null\r\nPurpose: Provides VatRate value for the row.\r\nWhen row is a comment, value is null.', dump_only=True)
    VatRateId = fields.String(description='Source: Get from /v2/articleaccountcodings', dump_only=True)
    WorkCostType = fields.Integer()
    WorkHours = fields.Number()

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceDraftValidationApi(Schema):
    Rows = fields.List(fields.Nested(lambda: CustomerInvoiceDraftValidationRowApi()), description='A set of invoice rows to validate. We match upon the line number.')
    TotalAmountInvoiceCurrency = fields.Number(description='Invoice total amount. Should be negative when credit invoice')
    TotalRoundingsInvoiceCurrency = fields.Number(description='Invoice Roundings amount. Can be both positive and negative depending on the rounding.')
    TotalVatAmountInvoiceCurrency = fields.Number(description='Invoice VAT amount. Should be negative when credit invoice')

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceDraftValidationRowApi(Schema):
    LineNumber = fields.Integer(description='Line number from the customer invoice draft')
    TotalAmountIncVatInvoiceCurrency = fields.Number(description='Total amount with VAT ((Quantity * Unit price) - Discount)')
    TotalAmountNoVatInvoiceCurrency = fields.Number(description='Total amount without VAT ((Quantity * Unit price) - Discount)')

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceRowApi(Schema):
    AmountNoVat = fields.Number(dump_only=True)
    ArticleId = fields.UUID(description='Purpose: Null if text row')
    ArticleNumber = fields.String(dump_only=True)
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CostCenterItemId1 = fields.UUID()
    CostCenterItemId2 = fields.UUID()
    CostCenterItemId3 = fields.UUID()
    DiscountPercentage = fields.Number(description='Format: 4 decimals', validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    GreenTechnologyType = fields.Integer(description='Type of green technology on the quote row, can be : \r\nNone = 0,\r\nSolarCellInstallation = 1,\r\nElectricEnergyStorageInstallation = 2,\r\nElectricVehicleChargingPointInstallation = 3,\r\nDefault value is 0.', validate=[Range(min=0, max=3, min_inclusive=True, max_inclusive=True)])
    Id = fields.UUID(description='Unique Id provided by eAccounting for every row', dump_only=True)
    IsServiceArticle = fields.Boolean(description='IsServiceArticle = FALSE if the sales category for the article is of the type Goods\r\nIsServiceArticle = TRUE if the sales category for the article is of the type Service.', dump_only=True)
    IsTextRow = fields.Boolean(dump_only=True)
    IsVatFree = fields.Boolean()
    IsWorkCost = fields.Boolean(dump_only=True)
    LineNumber = fields.Integer(dump_only=True)
    MaterialCosts = fields.Number(description='Only used for ROT/RUT invoices')
    PercentVat = fields.Number(dump_only=True)
    ProjectId = fields.UUID()
    Quantity = fields.Number(validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    Text = fields.String(description="Default: For non text rows, default value will be the article's name; for text rows, there should be at least one character in place")
    UnitAbbreviation = fields.String(dump_only=True)
    UnitAbbreviationEnglish = fields.String(dump_only=True)
    UnitId = fields.UUID(dump_only=True)
    UnitPrice = fields.Number(description='Format: 2 decimals allowed if the customer and currency are domestic or 4 decimals if customer or currency is foreign')
    VatRate = fields.Number(description='Default: null\r\nPurpose: Provides VatRate value for the row.\r\nWhen row is a comment, value is null.', dump_only=True)
    WorkCostType = fields.Integer(description='Only used for ROT/RUT invoices')
    WorkHours = fields.Number(description='Only used for ROT/RUT invoices')

    class Meta:
        unknown = INCLUDE



class CustomerInvoiceVatApi(Schema):
    AmountInvoiceCurrency = fields.Number(dump_only=True)
    VatAmountInvoiceCurrency = fields.Number(dump_only=True)
    VatPercent = fields.Number(dump_only=True)

    class Meta:
        unknown = INCLUDE



class CustomerLabelApi(Schema):
    Description = fields.String(description='Max length: 400 characters', validate=[Length(min=0, max=400, equal=None)])
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    Name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])

    class Meta:
        unknown = INCLUDE



class CustomerLedgerItemApi(Schema):
    CurrencyCode = fields.String(required=True, description='Max length: 3 characters', validate=[Length(min=0, max=3, equal=None)])
    CurrencyRate = fields.Number()
    CurrencyRateUnit = fields.Integer()
    CustomerId = fields.UUID(required=True, description='Source: Get from /v2/customers.')
    DueDate = fields.AwareDateTime(required=True, description='Format: YYYY-MM-DD')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    InvoiceDate = fields.AwareDateTime(required=True, description='Format: YYYY-MM-DD')
    InvoiceNumber = fields.Integer(required=True)
    IsCreditInvoice = fields.Boolean(required=True)
    ModifiedUtc = fields.AwareDateTime()
    PaymentReferenceNumber = fields.String(description='Purpose: Empty if UsesPaymentReferenceNumber not activated on the company. Use /v2/companysettings.', dump_only=True, validate=[Length(min=0, max=50, equal=None)])
    RemainingAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    RoundingsAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1, max=1, min_inclusive=True, max_inclusive=True)])
    TotalAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    VATAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    VoucherId = fields.UUID(required=True, description='Source: Get from /v2/vouchers/{fiscalyearid}.')

    class Meta:
        unknown = INCLUDE



class CustomerLedgerItemWithVoucherApi(Schema):
    CurrencyCode = fields.String(required=True, description='Max length: 3 characters', validate=[Length(min=0, max=3, equal=None)])
    CurrencyRate = fields.Number()
    CurrencyRateUnit = fields.Integer()
    CustomerId = fields.UUID(required=True, description='Source: Get from /v2/customers.')
    DueDate = fields.AwareDateTime(required=True, description='Format: YYYY-MM-DD')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    InvoiceDate = fields.AwareDateTime(required=True, description='Format: YYYY-MM-DD')
    InvoiceNumber = fields.Integer(required=True)
    IsCreditInvoice = fields.Boolean(required=True)
    ModifiedUtc = fields.AwareDateTime()
    PaymentReferenceNumber = fields.String(description='Empty if UsesPaymentReferenceNumber not activated on the company. Use /v2/companysettings.', validate=[Length(min=0, max=50, equal=None)])
    RemainingAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    RoundingsAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1, max=1, min_inclusive=True, max_inclusive=True)])
    TotalAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    VATAmountInvoiceCurrency = fields.Number(required=True, validate=[Range(min=-1000000000, max=1000000000, min_inclusive=True, max_inclusive=True)])
    Voucher = fields.Nested(lambda: VoucherApi(), required=True)

    class Meta:
        unknown = INCLUDE



class DefaultQuerySettings(Schema):
    EnableCount = fields.Boolean()
    EnableExpand = fields.Boolean()
    EnableFilter = fields.Boolean()
    EnableOrderBy = fields.Boolean()
    EnableSelect = fields.Boolean()
    MaxTop = fields.Integer()

    class Meta:
        unknown = INCLUDE



class DeliveryMethodApi(Schema):
    Code = fields.String(validate=[Length(min=0, max=20, equal=None)])
    Id = fields.UUID(dump_only=True)
    Name = fields.String(required=True, validate=[Length(min=0, max=100, equal=None)])
    NameEnglish = fields.String(validate=[Length(min=0, max=200, equal=None)])

    class Meta:
        unknown = INCLUDE



class DeliveryTermApi(Schema):
    Code = fields.String(validate=[Length(min=0, max=20, equal=None)])
    Editable = fields.Boolean()
    Id = fields.UUID(dump_only=True)
    Name = fields.String(required=True, validate=[Length(min=0, max=100, equal=None)])
    NameEnglish = fields.String(validate=[Length(min=0, max=200, equal=None)])

    class Meta:
        unknown = INCLUDE



class DirectDebitCustomerSettingsApi(Schema):
    Bic = fields.String(description='Length: 8 or 11 characters', validate=[Length(min=0, max=11, equal=None)])
    EndDate = fields.AwareDateTime()
    LatestDirectDebit = fields.AwareDateTime()
    MandateId = fields.String(description='Max length: 35 characters', validate=[Length(min=0, max=35, equal=None)])
    MandateType = fields.Integer(description='1 = Core, 2 = B2B', validate=[OneOf(choices=[1, 2], labels=[])])
    SequenceType = fields.Integer(description='1 = Recurring, 2 = Recurring, final, 3 = One-off', validate=[OneOf(choices=[1, 2, 3], labels=[])])
    SigningDate = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class DiscountAgreementApi(Schema):
    ChangedUtc = fields.AwareDateTime()
    Id = fields.UUID(description='Unique Id provided by eAccounting of the discount agreement', dump_only=True)
    IsActive = fields.Boolean()
    Name = fields.String()
    Notes = fields.String()
    Number = fields.Integer()

    class Meta:
        unknown = INCLUDE



class DocumentApi(Schema):
    ContentType = fields.String()
    CreatedUtc = fields.AwareDateTime()
    Id = fields.UUID()
    Name = fields.String()
    NameWithoutExtension = fields.String()
    Size = fields.Integer(description='Calculated in bytes')
    TemporaryUrl = fields.String(description='This is a temporary url that will expire and should not be stored.')
    Type = fields.Integer(description='0 = SupplierInvoiceDraftAttachment, 1 = SupplierInvoiceAttachment, 2 = SupplierInvoiceXml,\r\n10 = CustomerInvoiceXml, 11 = CustomerInvoicePdf, 12 = CustomerInvoicePaymentReminderPdf,\r\n13 = CompanyLogo, 14 = DocumentBackgroundPdf, 20 = PhotoReceipt, 21 = PhotoSupplierInvoice,\r\n30 = AutoInvoiceAssembly, 40 = FinvoiceReceiverInfoXml, 41 = VatReportPdf', validate=[OneOf(choices=[0, 1, 2, 10, 11, 12, 13, 14, 20, 21, 30, 40, 41, 42], labels=[])])

    class Meta:
        unknown = INCLUDE



class DocumentApprovalEventApi(Schema):
    CreatedByUserId = fields.UUID(description='The user id that did the action. Can be null if not undone. Use GET /v2/users')
    CreatedUtc = fields.AwareDateTime()
    DocumentApprovalStatus = fields.Integer(description='0 = None, 1 = Approved, 2 = Rejected, 3 = ReadyForApproval', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])

    class Meta:
        unknown = INCLUDE



class EdmReferentialConstraintPropertyPair(Schema):
    DependentProperty = fields.Nested(lambda: IEdmStructuralProperty())
    PrincipalProperty = fields.Nested(lambda: IEdmStructuralProperty())

    class Meta:
        unknown = INCLUDE



class EmailApi(Schema):
    CcRecipients = fields.List(fields.String(), description="Default: The customer's cc email addresses")
    Email = fields.String(description="Default: The customer's email address", validate=[Length(min=0, max=255, equal=None)])
    Message = fields.String(description='Default: The domestic or foreign company text from /v2/companysettings')
    Subject = fields.String(description="Default: The default email subject found in eAccounting followed by the company's name")

    class Meta:
        unknown = INCLUDE



class ExchangeRateApi(Schema):
    Date = fields.AwareDateTime(dump_only=True)
    Rate = fields.Number(dump_only=True)
    SourceCurrency = fields.String(dump_only=True)
    TargetCurrency = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class FilterClause(Schema):
    Expression = fields.Nested(lambda: SingleValueNode())
    ItemType = fields.Nested(lambda: IEdmTypeReference())
    RangeVariable = fields.Nested(lambda: RangeVariable())

    class Meta:
        unknown = INCLUDE



class FilterQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    FilterClause = fields.Nested(lambda: FilterClause())
    RawValue = fields.String(dump_only=True)
    Validator = fields.Nested(lambda: FilterQueryValidator())

    class Meta:
        unknown = INCLUDE



class FilterQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class FiscalYearApi(Schema):
    BookkeepingMethod = fields.Integer(description='Purpose: When posting fiscalyear, previous years bookkeeping method is chosen. 0 = Invoicing, 1 = Cash, 2 = NoBookkeeping', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    EndDate = fields.AwareDateTime()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsLockedForAccounting = fields.Boolean(dump_only=True)
    StartDate = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class FiscalYearUpdateApi(Schema):
    IsLockedForAccounting = fields.Boolean()

    class Meta:
        unknown = INCLUDE



class ForeignPaymentCodesAPI(Schema):
    Code = fields.Integer()
    CountryCode = fields.String()
    Description = fields.String()
    Id = fields.UUID()

    class Meta:
        unknown = INCLUDE



class IEdmDirectValueAnnotationsManager(Schema):

    class Meta:
        unknown = INCLUDE



class IEdmEntityContainer(Schema):
    Elements = fields.List(fields.Nested(lambda: IEdmEntityContainerElement()), dump_only=True)
    Name = fields.String(dump_only=True)
    Namespace = fields.String(dump_only=True)
    SchemaElementKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5], labels=[])])

    class Meta:
        unknown = INCLUDE



class IEdmEntityContainerElement(Schema):
    Container = fields.Nested(lambda: IEdmEntityContainer())
    ContainerElementKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    Name = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class IEdmExpression(Schema):
    ExpressionKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], labels=[])])

    class Meta:
        unknown = INCLUDE



class IEdmModel(Schema):
    DeclaredNamespaces = fields.List(fields.String(), dump_only=True)
    DirectValueAnnotationsManager = fields.Nested(lambda: IEdmDirectValueAnnotationsManager())
    EntityContainer = fields.Nested(lambda: IEdmEntityContainer())
    ReferencedModels = fields.List(fields.Nested(lambda: IEdmModel()), dump_only=True)
    SchemaElements = fields.List(fields.Nested(lambda: IEdmSchemaElement()), dump_only=True)
    VocabularyAnnotations = fields.List(fields.Nested(lambda: IEdmVocabularyAnnotation()), dump_only=True)

    class Meta:
        unknown = INCLUDE



class IEdmNavigationProperty(Schema):
    ContainsTarget = fields.Boolean(dump_only=True)
    DeclaringType = fields.Nested(lambda: IEdmStructuredType())
    Name = fields.String(dump_only=True)
    OnDelete = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1], labels=[])])
    Partner = fields.Nested(lambda: IEdmNavigationProperty())
    PropertyKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    ReferentialConstraint = fields.Nested(lambda: IEdmReferentialConstraint())
    Type = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class IEdmNavigationPropertyBinding(Schema):
    NavigationProperty = fields.Nested(lambda: IEdmNavigationProperty())
    Path = fields.Nested(lambda: IEdmPathExpression())
    Target = fields.Nested(lambda: IEdmNavigationSource())

    class Meta:
        unknown = INCLUDE



class IEdmNavigationSource(Schema):
    Name = fields.String(dump_only=True)
    NavigationPropertyBindings = fields.List(fields.Nested(lambda: IEdmNavigationPropertyBinding()), dump_only=True)
    Path = fields.Nested(lambda: IEdmPathExpression())
    Type = fields.Nested(lambda: IEdmType())

    class Meta:
        unknown = INCLUDE



class IEdmPathExpression(Schema):
    ExpressionKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], labels=[])])
    Path = fields.String(dump_only=True)
    PathSegments = fields.List(fields.String(), dump_only=True)

    class Meta:
        unknown = INCLUDE



class IEdmProperty(Schema):
    DeclaringType = fields.Nested(lambda: IEdmStructuredType())
    Name = fields.String(dump_only=True)
    PropertyKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    Type = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class IEdmReferentialConstraint(Schema):
    PropertyPairs = fields.List(fields.Nested(lambda: EdmReferentialConstraintPropertyPair()), dump_only=True)

    class Meta:
        unknown = INCLUDE



class IEdmSchemaElement(Schema):
    Name = fields.String(dump_only=True)
    Namespace = fields.String(dump_only=True)
    SchemaElementKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5], labels=[])])

    class Meta:
        unknown = INCLUDE



class IEdmStructuralProperty(Schema):
    DeclaringType = fields.Nested(lambda: IEdmStructuredType())
    DefaultValueString = fields.String(dump_only=True)
    Name = fields.String(dump_only=True)
    PropertyKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    Type = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class IEdmStructuredType(Schema):
    BaseType = fields.Nested(lambda: IEdmStructuredType())
    DeclaredProperties = fields.List(fields.Nested(lambda: IEdmProperty()), dump_only=True)
    IsAbstract = fields.Boolean(dump_only=True)
    IsOpen = fields.Boolean(dump_only=True)
    TypeKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], labels=[])])

    class Meta:
        unknown = INCLUDE



class IEdmTerm(Schema):
    AppliesTo = fields.String(dump_only=True)
    DefaultValue = fields.String(dump_only=True)
    Name = fields.String(dump_only=True)
    Namespace = fields.String(dump_only=True)
    SchemaElementKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5], labels=[])])
    Type = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class IEdmType(Schema):
    TypeKind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], labels=[])])

    class Meta:
        unknown = INCLUDE



class IEdmTypeReference(Schema):
    Definition = fields.Nested(lambda: IEdmType())
    IsNullable = fields.Boolean(dump_only=True)

    class Meta:
        unknown = INCLUDE



class IEdmVocabularyAnnotatable(Schema):

    class Meta:
        unknown = INCLUDE



class IEdmVocabularyAnnotation(Schema):
    Qualifier = fields.String(dump_only=True)
    Target = fields.Nested(lambda: IEdmVocabularyAnnotatable())
    Term = fields.Nested(lambda: IEdmTerm())
    Value = fields.Nested(lambda: IEdmExpression())

    class Meta:
        unknown = INCLUDE



class IServiceProvider(Schema):

    class Meta:
        unknown = INCLUDE



class InventoryAccountingTemplateApi(Schema):
    AccumulatedImpairmentLossAccountNumber = fields.Integer()
    AccumulatedImpairmentLossAccountUseCostCenter = fields.Boolean()
    Active = fields.Boolean()
    AppreciationAccountUseCostCenter = fields.Boolean()
    AppreciationsAccountNumber = fields.Integer()
    CapitalGainAccountNumber = fields.Integer()
    CapitalGainAccountUseCostCenter = fields.Boolean()
    CapitalLossAccountNumber = fields.Integer()
    CapitalLossAccountUseCostCenter = fields.Boolean()
    DepreciationAssetAccountNumber = fields.Integer()
    DepreciationAssetAccountUseCostCenter = fields.Boolean()
    DepreciationResultAccountNumber = fields.Integer()
    DepreciationResultAccountUseCostCenter = fields.Boolean()
    Id = fields.UUID()
    ImpairmentLossAccountNumber = fields.Integer()
    ImpairmentLossAccountUseCostCenter = fields.Boolean()
    InventoryAccountNumber = fields.Integer()
    InventoryAccountUseCostCenter = fields.Boolean()
    IsCustom = fields.Boolean()
    Name = fields.String()
    NameEnglish = fields.String()
    NoDepreciations = fields.Boolean()
    ReversalOfImpairmentAccountNumber = fields.Integer()
    ReversalOfImpairmentAccountUseCostCenter = fields.Boolean()
    TaxationDepreciation = fields.String()

    class Meta:
        unknown = INCLUDE



class InventoryAccumulatedDepreciationApi(Schema):
    DepreciationForTheYear = fields.Number()
    FiscalYearId = fields.UUID()
    Id = fields.UUID()
    OpeningAccumulatedDepreciation = fields.Number()

    class Meta:
        unknown = INCLUDE



class InventoryEventApi(Schema):
    Amount = fields.Number()
    BookkeepingDate = fields.AwareDateTime()
    CreatedUtc = fields.AwareDateTime()
    CurrentValueBeforeEvent = fields.Number()
    Id = fields.UUID()
    Type = fields.Integer(description='Depreciation = 0, Sale = 1, Disposal = 4, ValueChange = 5, Appreciation = 6, ImpairmentLoss = 7, ReversalOfImpairment = 8, AdditionalDepreciation = 9, CostOfAquisitionAdjustement = 10, DepreciationBasisAdjustement = 11', validate=[OneOf(choices=[0, 1, 4, 5, 6, 7, 8, 9, 10, 11], labels=[])])
    UndoBookkeepingDate = fields.AwareDateTime()
    UndoVoucherId = fields.UUID()
    Undone = fields.Boolean()
    VoucherId = fields.UUID()

    class Meta:
        unknown = INCLUDE



class InventoryItemApi(Schema):
    CostCenterItemId1 = fields.UUID()
    CostCenterItemId2 = fields.UUID()
    CostCenterItemId3 = fields.UUID()
    CreatedUtc = fields.AwareDateTime()
    CurrentValue = fields.Number()
    Depreciate = fields.Boolean()
    DepreciationBasis = fields.Number()
    DepreciationStartType = fields.Integer(description='PurchaseMonth = 1, MonthAfterPurchaseMonth = 2, FirstMonthOfPurchaseYear = 3', validate=[OneOf(choices=[1, 2, 3], labels=[])])
    Events = fields.List(fields.Nested(lambda: InventoryEventApi()))
    FirstDepreciationDate = fields.AwareDateTime()
    HasUpcomingDepreciations = fields.Boolean()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting')
    InventoryAccountingTemplate = fields.Nested(lambda: InventoryAccountingTemplateApi())
    InventoryItemStatus = fields.Integer(description='Inactive = 1, Active = 2, Sold = 3, Dispose = 4', validate=[OneOf(choices=[1, 2, 3, 4], labels=[])])
    LatestDepreciationDate = fields.AwareDateTime()
    LifeSpanInMonths = fields.Integer()
    ModifiedUtc = fields.AwareDateTime()
    Name = fields.String()
    Number = fields.Integer()
    OpeningDepreciations = fields.List(fields.Nested(lambda: InventoryAccumulatedDepreciationApi()))
    ProjectId = fields.UUID()
    PurchaseDate = fields.AwareDateTime()
    PurchasePrice = fields.Number()
    ResidualValue = fields.Number()

    class Meta:
        unknown = INCLUDE



class InvoicePaymentApi(Schema):
    BankFeeAmount = fields.Number(validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True)])
    BankTransactionId = fields.UUID(description='Purpose: The id inside eAccounting of the bank transaction corresponding to the payment', dump_only=True)
    CompanyBankAccountId = fields.UUID(required=True, description='The bank account to which the payment is recorded')
    DomesticPaymentAmount = fields.Number(description='Only for non domestic invoices paid with cheque account. If bank fee: for customer invoices, extract that amount here. For supplier invoices, do not extract bank fee amount here.')
    FactoringFeeAccountNumber = fields.Integer(description='Factoring account number, supported only for customer invoice payments')
    FactoringFeeAmount = fields.Number(description='Factoring fee amount for the current invoice, supported only for customer invoice payments')
    PaymentAmount = fields.Number(required=True, description='Amount in invoice currency. If bank fee: for customer invoices, extract that amount here. For supplier invoices, do not extract bank fee amount here.')
    PaymentCurrency = fields.String(required=True)
    PaymentDate = fields.AwareDateTime(required=True, description='Future dates cannot be set. Date format: yyyy-mm-dd')
    PaymentType = fields.Integer(required=True, description='1 = PartialPayment\r\n2 = CompletePayment\r\n3 = Rounding: The payment amount must be rounded on the customer side and the payment of the invoice will be recorded as fully paid.\r\nThe difference between entered amount and the total amount will count as rounding.\r\n4 = Bank Charge', validate=[Range(min=1, max=4, min_inclusive=True, max_inclusive=True), OneOf(choices=[1, 2, 3, 4], labels=[])])
    Reference = fields.String(validate=[Length(min=0, max=100, equal=None)])

    class Meta:
        unknown = INCLUDE



class InvoiceUrlApi(Schema):
    Url = fields.String(description='URL to the invoice.')

    class Meta:
        unknown = INCLUDE



class LedgerVoucherRelationApi(Schema):
    Amount = fields.Number(dump_only=True)
    CustomerId = fields.UUID(dump_only=True)
    SupplierId = fields.UUID(dump_only=True)

    class Meta:
        unknown = INCLUDE



class MessageApi(Schema):
    CreatedByUserId = fields.UUID(dump_only=True)
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    Id = fields.UUID(dump_only=True)
    MessageThreadId = fields.UUID(dump_only=True)
    ModifiedByUserId = fields.UUID(dump_only=True)
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Text = fields.String(validate=[Length(min=0, max=256, equal=None)])

    class Meta:
        unknown = INCLUDE



class MessageReceiverApi(Schema):
    IsCurrentUser = fields.Boolean(dump_only=True)
    Status = fields.Integer(description='The status type of the message \r\nNone = 0, New = 1, Read = 2, Open = 3, Close = 4', dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    UserId = fields.UUID(required=True)

    class Meta:
        unknown = INCLUDE



class MessageStatusApi(Schema):
    Status = fields.Integer(required=True, description='The status type of the message \r\nNone = 0, New = 1, Read = 2, Open = 3, Close = 4', validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])

    class Meta:
        unknown = INCLUDE



class MessageThreadApi(Schema):
    DocumentId = fields.UUID(description='Default: No attached document\r\nUsed in combination with DocumentType, represents the unique identifier of the document to which it is attached')
    DocumentNumber = fields.String(dump_only=True)
    DocumentType = fields.Integer(description='The document type to which the message thread is attached \r\nNone = 0, CustomerInvoice = 1, CustomerInvoiceDraft = 2, SupplierInvoice = 3, Voucher = 4, Quotation = 5, Order = 6, SupplierInvoiceDraft = 7, WebshopOrder = 8, Customer = 9, Receipt = 10, Article = 11, VatReport = 12, Supplier = 13, Inventory = 14, Employee = 15, Payslip = 16, Image = 17, Reconciliation = 18,  QuoteDraft = 19, VoucherDraft = 20, OrderDraft = 21', validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], labels=[])])
    Id = fields.UUID(dump_only=True)
    IsClosed = fields.Boolean(dump_only=True)
    LastMessage = fields.Nested(lambda: MessageApi())
    MessageReceivers = fields.List(fields.Nested(lambda: MessageReceiverApi()))
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Subject = fields.String(validate=[Length(min=0, max=40, equal=None)])

    class Meta:
        unknown = INCLUDE



class MessageToPostApi(Schema):
    DocumentId = fields.UUID()
    DocumentType = fields.Integer(required=True, validate=[Range(min=0, max=21, min_inclusive=True, max_inclusive=True), OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], labels=[])])
    Message = fields.String(required=True, validate=[Length(min=0, max=256, equal=None)])
    MessageReceivers = fields.List(fields.Nested(lambda: MessageReceiverApi()))
    Subject = fields.String(required=True, validate=[Length(min=0, max=40, equal=None)])

    class Meta:
        unknown = INCLUDE



class NoteApi(Schema):
    AttachedTo = fields.UUID(description='The document Id to which the note can be attached')
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    DocumentType = fields.Integer(description='The document type to which the note is attached \r\nNone = 0, CustomerInvoice = 1, CustomerInvoiceDraft = 2, SupplierInvoice = 3, Voucher = 4, Quotation = 5, Order = 6, SupplierInvoiceDraft = 7, WebshopOrder = 8, Customer = 9, Receipt = 10, Article = 11, VatReport = 12, Supplier = 13, Inventory = 14, Employee = 15, Payslip = 16, Image = 17, Reconciliation = 18, QuoteDraft = 19, VoucherDraft = 20, OrderDraft = 21', validate=[Range(min=0, max=21, min_inclusive=True, max_inclusive=True), OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], labels=[])])
    Id = fields.UUID(dump_only=True)
    IsDone = fields.Boolean()
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Subject = fields.String(validate=[Length(min=0, max=40, equal=None)])
    Text = fields.String(validate=[Length(min=0, max=256, equal=None)])
    UserId = fields.UUID(dump_only=True)

    class Meta:
        unknown = INCLUDE



class ODataPath(Schema):
    EdmType = fields.Nested(lambda: IEdmType())
    NavigationSource = fields.Nested(lambda: IEdmNavigationSource())
    Path = fields.List(fields.Nested(lambda: ODataPathSegment()), dump_only=True)
    PathTemplate = fields.String(dump_only=True)
    Segments = fields.List(fields.Nested(lambda: ODataPathSegment()), dump_only=True)

    class Meta:
        unknown = INCLUDE



class ODataPathSegment(Schema):
    EdmType = fields.Nested(lambda: IEdmType())
    Identifier = fields.String()

    class Meta:
        unknown = INCLUDE



class ODataQueryContext(Schema):
    DefaultQuerySettings = fields.Nested(lambda: DefaultQuerySettings())
    ElementClrType = fields.String(dump_only=True)
    ElementType = fields.Nested(lambda: IEdmType())
    Model = fields.Nested(lambda: IEdmModel())
    NavigationSource = fields.Nested(lambda: IEdmNavigationSource())
    Path = fields.Nested(lambda: ODataPath())
    RequestContainer = fields.Nested(lambda: IServiceProvider())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAccountApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAccountBalanceAPI(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAccountTypesAPI(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAllocationPeriodApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAppStoreActivationStatusApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsArticleAccountCodingAPI(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsArticleApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsArticleLabelApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAttachmentResultApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsAutoInvoiceAddressApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsBankAccountApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsBankApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsBankTransactionApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCompanySettingsApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCostCenterApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCostCenterItemApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCountryApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCurrencyApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCustomerApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCustomerInvoiceApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCustomerInvoiceDraftApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCustomerLabelApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsCustomerLedgerItemApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsDeliveryMethodApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsDeliveryTermApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsDiscountAgreementApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsDocumentApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsExchangeRateApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsFiscalYearApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsForeignPaymentCodesAPI(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsInventoryItemApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsLedgerVoucherRelationApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsMessageApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsMessageThreadApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsNoteApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsOpeningBalancesApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsOrderApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsPartnerResourceLinkApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsProjectApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsQuoteApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsSalesPriceListApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsSalesPriceListRowApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsStandardAccountApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsSupplierApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsSupplierInvoiceApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsSupplierInvoiceDraftApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsTermsOfPaymentApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsUnitApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsUserApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsVatCodeApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsVatCodeRateApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsVatReportApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsVoucherApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsVoucherDraftApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryOptionsWebshopOrderApi(Schema):
    Apply = fields.Nested(lambda: ApplyQueryOption())
    Context = fields.Nested(lambda: ODataQueryContext())
    Count = fields.Nested(lambda: CountQueryOption())
    Filter = fields.Nested(lambda: FilterQueryOption())
    IfMatch = fields.Field(dump_only=True)
    IfNoneMatch = fields.Field(dump_only=True)
    OrderBy = fields.Nested(lambda: OrderByQueryOption())
    RawValues = fields.Nested(lambda: ODataRawQueryOptions())
    Request = fields.Field(dump_only=True)
    SelectExpand = fields.Nested(lambda: SelectExpandQueryOption())
    Skip = fields.Nested(lambda: SkipQueryOption())
    Top = fields.Nested(lambda: TopQueryOption())
    Validator = fields.Nested(lambda: ODataQueryValidator())

    class Meta:
        unknown = INCLUDE



class ODataQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class ODataRawQueryOptions(Schema):
    Apply = fields.String(dump_only=True)
    Count = fields.String(dump_only=True)
    DeltaToken = fields.String(dump_only=True)
    Expand = fields.String(dump_only=True)
    Filter = fields.String(dump_only=True)
    Format = fields.String(dump_only=True)
    OrderBy = fields.String(dump_only=True)
    Select = fields.String(dump_only=True)
    Skip = fields.String(dump_only=True)
    SkipToken = fields.String(dump_only=True)
    Top = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class OpeningBalancesApi(Schema):
    Balance = fields.Number(description='The opening balance amount on the account')
    Name = fields.String(description='The name of the account')
    Number = fields.Integer(description='The account number')

    class Meta:
        unknown = INCLUDE



class OrderApi(Schema):
    Amount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    BuyersOrderReference = fields.String(validate=[Length(min=0, max=35, equal=None)])
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CurrencyCode = fields.String(required=True, description='Max length: 3 characters', validate=[Length(min=0, max=3, equal=None)])
    CustomerId = fields.UUID(required=True)
    CustomerIsPrivatePerson = fields.Boolean(description="Purpose: This property will be set automatically depending on it's value which is set on the customer level", dump_only=True)
    CustomerName = fields.String(description='Readonly\r\nThe selected customers name', dump_only=True)
    CustomerNumber = fields.String(description="Readonly\r\nThe selected customer's number", dump_only=True)
    DeliveredAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveredRoundingsAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveredVatAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryAddress1 = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryAddress2 = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCity = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryCountryCode = fields.String(description='Max length: 2 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=2, equal=None)])
    DeliveryCustomerName = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD. \r\nDefault: null')
    DeliveryMethodCode = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=20, equal=None)])
    DeliveryMethodName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    DeliveryPostalCode = fields.String(description='Max length: 10 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=10, equal=None)])
    DeliveryTermCode = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    DeliveryTermName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    EuThirdParty = fields.Boolean(required=True)
    HouseWorkAmount = fields.Number()
    HouseWorkAutomaticDistribution = fields.Boolean()
    HouseWorkCorporateIdentityNumber = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    HouseWorkPropertyName = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IncludesVat = fields.Boolean(description='Returns true if Amount and UnitPrice includes VAT. It will be automatically added based on company settings and customer type(private person or company).', dump_only=True)
    InvoiceAddress1 = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    InvoiceAddress2 = fields.String(description='Max length: 50 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=50, equal=None)])
    InvoiceCity = fields.String(description='Default: The value on the selected customer')
    InvoiceCountryCode = fields.String(description='Max length: 2 characters\r\nThe value on the selected customer', validate=[Length(min=0, max=2, equal=None)])
    InvoiceCustomerName = fields.String(description="Readonly\r\nThe selected customer's name", validate=[Length(min=0, max=50, equal=None)])
    InvoicePostalCode = fields.String(description='Max length: 10 characters\r\nDefault: The value on the selected customer', validate=[Length(min=0, max=10, equal=None)])
    IsNotDelivered = fields.Boolean(dump_only=True)
    MaxAllowedTaxReductionAmount = fields.Number(description='Default: maximum allowed tax reduction amount.', dump_only=True)
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{notesId}', dump_only=True)
    Number = fields.Integer(description='Purpose: This property will be set automatically upon creation of an order', dump_only=True)
    OrderDate = fields.AwareDateTime(required=True, description='Format: YYYY-MM-DD')
    OurReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])
    Persons = fields.List(fields.Nested(lambda: SalesDocumentRotRutReductionPersonApi()))
    ReverseChargeOnConstructionServices = fields.Boolean(required=True)
    RotPropertyType = fields.Integer(description='1 = Apartment, 2 = Property\r\nLeave blank or set to null if you do not intend to use ROT or Green Technology functionality')
    RotReducedInvoicingPercent = fields.Number(description='Format: 4 decimals', dump_only=True)
    RotReducedInvoicingType = fields.Integer(required=True, description='0 = None, 1 = Rot, 2 = Rut', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    RoundingsAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    Rows = fields.List(fields.Nested(lambda: OrderRowApi()))
    SalesDocumentAttachments = fields.List(fields.UUID(), description='Fetch SalesDocumentAttachments via GET /v2/salesdocumentattachments/{attachmentId}', dump_only=True)
    ShippedDateTime = fields.AwareDateTime(description='Format: YYYY-MM-DD. \r\nDefault: null')
    Status = fields.Integer(required=True, description='1 = Draft, 2 = Ongoing, 3 = Shipped, 4 = Invoiced', validate=[Range(min=1, max=4, min_inclusive=True, max_inclusive=True), OneOf(choices=[1, 2, 3, 4], labels=[])])
    UsesGreenTechnology = fields.Boolean(description='Set to true if this order benefits from deduction on Green Technology.\r\nIf set to true the order must have RotReducedInvoicingType set to normal and contain at least one row with applicable deduction.')
    VatAmount = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    YourReference = fields.String(description='Max length: 100 characters', validate=[Length(min=0, max=100, equal=None)])

    class Meta:
        unknown = INCLUDE



class OrderByClause(Schema):
    Direction = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1], labels=[])])
    Expression = fields.Nested(lambda: SingleValueNode())
    ItemType = fields.Nested(lambda: IEdmTypeReference())
    RangeVariable = fields.Nested(lambda: RangeVariable())
    ThenBy = fields.Nested(lambda: OrderByClause())

    class Meta:
        unknown = INCLUDE



class OrderByNode(Schema):
    Direction = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1], labels=[])])

    class Meta:
        unknown = INCLUDE



class OrderByQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    OrderByClause = fields.Nested(lambda: OrderByClause())
    OrderByNodes = fields.List(fields.Nested(lambda: OrderByNode()), dump_only=True)
    RawValue = fields.String(dump_only=True)
    Validator = fields.Nested(lambda: OrderByQueryValidator())

    class Meta:
        unknown = INCLUDE



class OrderByQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class OrderRowApi(Schema):
    Amount = fields.Number(description='Returns a total amount of row. Format: 2 decimals')
    ArticleId = fields.UUID(description='Can be null if the row is a text row')
    ArticleNumber = fields.String(description='Max length: 40 characters', validate=[Length(min=0, max=40, equal=None)])
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    DeliveredQuantity = fields.Number(description='Format: 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DiscountPercentage = fields.Number(description='Format: 4 decimals', validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    EligibleForReverseChargeOnVat = fields.Boolean(required=True)
    GreenTechnologyType = fields.Integer(description='Type of green technology on the order row, can be: \r\nNone = 0,\r\nSolarCellInstallation = 1,\r\nElectricEnergyStorageInstallation = 2,\r\nElectricVehicleChargingPointInstallation = 3,\r\nDefault value is 0.', validate=[Range(min=0, max=3, min_inclusive=True, max_inclusive=True)])
    Id = fields.UUID(description='Unique Id provided by eAccounting for every row', dump_only=True)
    IsServiceArticle = fields.Boolean(description='IsServiceArticle = FALSE if the sales category for the article is of the type Goods\r\nIsServiceArticle = TRUE if the sales category for the article is of the type Service.', dump_only=True)
    IsTextRow = fields.Boolean(required=True)
    IsWorkCost = fields.Boolean(required=True)
    LineNumber = fields.Integer(required=True, validate=[Range(min=0, max=1000, min_inclusive=True, max_inclusive=True)])
    MaterialCosts = fields.Number(description='Only used for ROT/RUT.')
    ProjectId = fields.UUID()
    Quantity = fields.Number(description='Format: 4 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    Text = fields.String(description="Max length: 2000 characters.\r\nDefault: For non text rows, default value will be the article's name; for text rows, there should be at least one character in place", validate=[Length(min=0, max=2000, equal=None)])
    UnitId = fields.UUID(description='Source: Get from /v2/units/{id}', dump_only=True)
    UnitPrice = fields.Number(description='Format: 2 decimals allowed if the customer and currency are domestic or 4 decimals if customer or currency is foreign')
    VatRate = fields.Number(description='Default: null\r\nPurpose: Provides VatRate value for the row.\r\nWhen row is a comment, value is null.', dump_only=True)
    WorkCostType = fields.Integer(description='None = 0, RotConstructionWork = 1, RotElectricalWork = 2, RotGlassSheetMetalWork = 3, RotGroundWork = 4, RotBrickWork = 5, RotPaintDecorateWork = 6, RotPlumbWork = 7\r\nRutCleanJobWork = 9, RutCareClothTextile = 10, RutCook = 11, RutSnowRemove = 12, RutGarden = 13, RutBabySitt = 14, RutOtherCare = 15, RutHouseWorkHelp = 17\r\nRutRemovalServices = 18, RutITServices = 19, RotHeatPump = 20, RotHeatPump2 = 21, RutHomeAppliances = 22')
    WorkHours = fields.Number(description='Only used for ROT/RUT.')

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAccountApi(Schema):
    Data = fields.List(fields.Nested(lambda: AccountApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAccountBalanceAPI(Schema):
    Data = fields.List(fields.Nested(lambda: AccountBalanceAPI()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAccountTypesAPI(Schema):
    Data = fields.List(fields.Nested(lambda: AccountTypesAPI()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAllocationPeriodApi(Schema):
    Data = fields.List(fields.Nested(lambda: AllocationPeriodApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAppStoreActivationStatusApi(Schema):
    Data = fields.List(fields.Nested(lambda: AppStoreActivationStatusApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseArticleAccountCodingAPI(Schema):
    Data = fields.List(fields.Nested(lambda: ArticleAccountCodingAPI()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseArticleApi(Schema):
    Data = fields.List(fields.Nested(lambda: ArticleApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseArticleLabelApi(Schema):
    Data = fields.List(fields.Nested(lambda: ArticleLabelApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAttachmentResultApi(Schema):
    Data = fields.List(fields.Nested(lambda: AttachmentResultApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseAutoInvoiceAddressApi(Schema):
    Data = fields.List(fields.Nested(lambda: AutoInvoiceAddressApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseBankAccountApi(Schema):
    Data = fields.List(fields.Nested(lambda: BankAccountApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseBankApi(Schema):
    Data = fields.List(fields.Nested(lambda: BankApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseBankTransactionApi(Schema):
    Data = fields.List(fields.Nested(lambda: BankTransactionApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCostCenterApi(Schema):
    Data = fields.List(fields.Nested(lambda: CostCenterApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCountryApi(Schema):
    Data = fields.List(fields.Nested(lambda: CountryApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCurrencyApi(Schema):
    Data = fields.List(fields.Nested(lambda: CurrencyApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCustomerApi(Schema):
    Data = fields.List(fields.Nested(lambda: CustomerApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCustomerInvoiceApi(Schema):
    Data = fields.List(fields.Nested(lambda: CustomerInvoiceApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCustomerInvoiceDraftApi(Schema):
    Data = fields.List(fields.Nested(lambda: CustomerInvoiceDraftApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCustomerLabelApi(Schema):
    Data = fields.List(fields.Nested(lambda: CustomerLabelApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseCustomerLedgerItemApi(Schema):
    Data = fields.List(fields.Nested(lambda: CustomerLedgerItemApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseDeliveryMethodApi(Schema):
    Data = fields.List(fields.Nested(lambda: DeliveryMethodApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseDeliveryTermApi(Schema):
    Data = fields.List(fields.Nested(lambda: DeliveryTermApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseDiscountAgreementApi(Schema):
    Data = fields.List(fields.Nested(lambda: DiscountAgreementApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseFiscalYearApi(Schema):
    Data = fields.List(fields.Nested(lambda: FiscalYearApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseForeignPaymentCodesAPI(Schema):
    Data = fields.List(fields.Nested(lambda: ForeignPaymentCodesAPI()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseInventoryItemApi(Schema):
    Data = fields.List(fields.Nested(lambda: InventoryItemApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseLedgerVoucherRelationApi(Schema):
    Data = fields.List(fields.Nested(lambda: LedgerVoucherRelationApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseOpeningBalancesApi(Schema):
    Data = fields.List(fields.Nested(lambda: OpeningBalancesApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseOrderApi(Schema):
    Data = fields.List(fields.Nested(lambda: OrderApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponsePartnerResourceLinkApi(Schema):
    Data = fields.List(fields.Nested(lambda: PartnerResourceLinkApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseProjectApi(Schema):
    Data = fields.List(fields.Nested(lambda: ProjectApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseQuoteApi(Schema):
    Data = fields.List(fields.Nested(lambda: QuoteApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseSalesPriceListApi(Schema):
    Data = fields.List(fields.Nested(lambda: SalesPriceListApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseSalesPriceListRowApi(Schema):
    Data = fields.List(fields.Nested(lambda: SalesPriceListRowApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseStandardAccountApi(Schema):
    Data = fields.List(fields.Nested(lambda: StandardAccountApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseSupplierApi(Schema):
    Data = fields.List(fields.Nested(lambda: SupplierApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseSupplierInvoiceApi(Schema):
    Data = fields.List(fields.Nested(lambda: SupplierInvoiceApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseSupplierInvoiceDraftApi(Schema):
    Data = fields.List(fields.Nested(lambda: SupplierInvoiceDraftApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseTermsOfPaymentApi(Schema):
    Data = fields.List(fields.Nested(lambda: TermsOfPaymentApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseUnitApi(Schema):
    Data = fields.List(fields.Nested(lambda: UnitApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseUserApi(Schema):
    Data = fields.List(fields.Nested(lambda: UserApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseVatCodeApi(Schema):
    Data = fields.List(fields.Nested(lambda: VatCodeApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseVatCodeRateApi(Schema):
    Data = fields.List(fields.Nested(lambda: VatCodeRateApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseVatReportApi(Schema):
    Data = fields.List(fields.Nested(lambda: VatReportApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseVoucherApi(Schema):
    Data = fields.List(fields.Nested(lambda: VoucherApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseVoucherDraftApi(Schema):
    Data = fields.List(fields.Nested(lambda: VoucherDraftApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginatedResponseWebshopOrderApi(Schema):
    Data = fields.List(fields.Nested(lambda: WebshopOrderApi()), required=True)
    Meta = fields.Nested(lambda: PaginationMetadata(), required=True)

    class Meta:
        unknown = INCLUDE



class PaginationMetadata(Schema):
    CurrentPage = fields.Integer(required=True)
    PageSize = fields.Integer(required=True)
    ServerTimeUtc = fields.AwareDateTime(required=True)
    TotalNumberOfPages = fields.Integer(required=True)
    TotalNumberOfResults = fields.Integer(required=True)

    class Meta:
        unknown = INCLUDE



class PartnerResourceLinkApi(Schema):
    Href = fields.String(required=True, description='Link to the third party solution page', validate=[Length(min=0, max=256, equal=None)])
    Id = fields.UUID(description='Purpose: Id provided by eAccounting', dump_only=True)
    PartnerCompanyName = fields.String(required=True, validate=[Length(min=0, max=100, equal=None)])
    PartnerSystemName = fields.String(required=True, validate=[Length(min=0, max=100, equal=None)])
    ResourceId = fields.UUID(required=True, description='Purpose: Link to the resource in eAccounting')
    ResourceType = fields.Integer(required=True, description='0 = Article, 1 = Customer, 2 = Supplier, 3 = CustomerInvoice, 4 = SupplierInvoice,\r\n5 = CustomerInvoiceDraft, 6 = SupplierInvoiceDraft', validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6], labels=[])])

    class Meta:
        unknown = INCLUDE



class PaymentReminderEmailApi(Schema):
    EmailDetails = fields.Nested(lambda: EmailApi())
    LatePaymentFee = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=10000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class PaymentVoucherApi(Schema):
    NumberSeries = fields.String(description='Purpose: Returns the number series. Use parameter useDefaultVoucherSeries with false value to set Series.')
    Rows = fields.List(fields.Nested(lambda: PaymentVoucherRowApi()), required=True)
    VoucherDate = fields.AwareDateTime(required=True, description='Format: yyyy-mm-dd')
    VoucherText = fields.String(required=True, description='Max length: 1000 characters', validate=[Length(min=0, max=1000, equal=None)])

    class Meta:
        unknown = INCLUDE



class PaymentVoucherRowApi(Schema):
    AccountNumber = fields.Integer(required=True, validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DebitAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    PayableId = fields.UUID(description='Purpose: Id of the supplier invoice to be paid')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    ReceivableId = fields.UUID(description='Purpose: Id of the customer invoice to be paid')
    TransactionText = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    VatCodeId = fields.UUID()
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class ProjectApi(Schema):
    CustomerId = fields.UUID(description='Source: Get from /v2/customers')
    CustomerName = fields.String(description='Purpose: CustomerName depending on CustomerId', dump_only=True)
    EndDate = fields.AwareDateTime()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    ModifiedUtc = fields.AwareDateTime(description='Purpose: Is automatically set', dump_only=True)
    Name = fields.String(required=True, description='Max length: 200 characters', validate=[Length(min=0, max=200, equal=None)])
    Notes = fields.String(description='Max length: 500 characters', validate=[Length(min=0, max=500, equal=None)])
    Number = fields.String(required=True, description='Max length: 9 characters', validate=[Length(min=0, max=9, equal=None)])
    StartDate = fields.AwareDateTime(required=True)
    Status = fields.Integer(description='1 = Ongoing, 2 = Finished', validate=[OneOf(choices=[1, 2], labels=[])])

    class Meta:
        unknown = INCLUDE



class QuoteApi(Schema):
    ApprovedDate = fields.AwareDateTime(description='Default: null. Value will be set if the quote is approved', dump_only=True)
    BuyersOrderReference = fields.String(validate=[Length(min=0, max=35, equal=None)])
    CompanyReference = fields.String(description='Equivalent for property OurReference in OrderApi and CustomerInvoiceApi models.', validate=[Length(min=0, max=100, equal=None)])
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CurrencyCode = fields.String(dump_only=True)
    CurrencyRate = fields.Number(dump_only=True)
    CustomerId = fields.UUID(required=True)
    CustomerIsPrivatePerson = fields.Boolean(dump_only=True)
    CustomerName = fields.String(description="Readonly\r\nThe selected customer's name", dump_only=True)
    CustomerNumber = fields.String(description="Readonly\r\nThe selected customer's number", dump_only=True)
    CustomerReference = fields.String(description='Equivalent for property YourReference in OrderApi and CustomerInvoiceApi models.', validate=[Length(min=0, max=100, equal=None)])
    DeliveryAddress1 = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryAddress2 = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryCity = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryCountryCode = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryCustomerName = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD. Default: null')
    DeliveryMethodCode = fields.String(dump_only=True)
    DeliveryMethodName = fields.String(dump_only=True)
    DeliveryPostalCode = fields.String(description='Default: The value on the selected customer', dump_only=True)
    DeliveryTermCode = fields.String(dump_only=True)
    DeliveryTermName = fields.String(dump_only=True)
    DueDate = fields.AwareDateTime(description='Format: YYYY-MM-DD. Default: null')
    EuThirdParty = fields.Boolean()
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IncludesVat = fields.Boolean(description='Returns true if Amount and UnitPrice includes VAT. \r\nIt will be automatically added based on company settings and customer type(private person or company).', dump_only=True)
    InvoiceAddress1 = fields.String(description='Default: The value on the selected customer', dump_only=True)
    InvoiceAddress2 = fields.String(description='Default: The value on the selected customer', dump_only=True)
    InvoiceCity = fields.String(description='Default: The value on the selected customer', dump_only=True)
    InvoiceCountryCode = fields.String(description='Default: The value on the selected customer', dump_only=True)
    InvoiceCustomerName = fields.String(dump_only=True)
    InvoicePostalCode = fields.String(description='Default: The value on the selected customer', dump_only=True)
    IsDomestic = fields.Boolean(dump_only=True)
    IsNotDelivered = fields.Boolean(dump_only=True)
    MaxAllowedTaxReductionAmount = fields.Number(description='Default: maximum allowed tax reduction amount.', dump_only=True)
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    ModifiedUtc = fields.AwareDateTime(description='Date and time of the last document modification.', dump_only=True)
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{notesId}', dump_only=True)
    Number = fields.Integer(dump_only=True)
    Persons = fields.List(fields.Nested(lambda: SalesDocumentRotRutReductionPersonApi()), description='Only available for ROT/RUT or Green Technology')
    QuoteDate = fields.AwareDateTime(description='Format: YYYY-MM-DD. Default: null')
    RotPropertyType = fields.Integer(description='1 = Apartment, 2 = Property\r\nLeave blank or set to null if you do not intend to use ROT or Green Technology functionality')
    RotReducedInvoicingAmount = fields.Number(description='Format: 2 decimals')
    RotReducedInvoicingAutomaticDistribution = fields.Boolean(dump_only=True)
    RotReducedInvoicingOrgNumber = fields.String(description='Max length: 11 characters')
    RotReducedInvoicingPercent = fields.Number(description='Format: 4 decimals', dump_only=True)
    RotReducedInvoicingPropertyName = fields.String(description='Max length: 40 characters')
    RotReducedInvoicingType = fields.Integer(description='0 = Normal, 1 = Rot, 2 = Rut', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    RoundingsAmount = fields.Number(dump_only=True)
    Rows = fields.List(fields.Nested(lambda: QuoteRowApi()))
    SalesDocumentAttachments = fields.List(fields.UUID(), description='Fetch SalesDocumentAttachments via GET /v2/salesdocumentattachments/{attachmentId}', dump_only=True)
    Status = fields.Integer(description='0 = Draft, 1 = Ongoing, 2 = Approved, 3 = Invoiced, 4 = OrderCreated', dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    TermsOfPayment = fields.Nested(lambda: TermsOfPaymentApi())
    TotalAmount = fields.Number(dump_only=True)
    UsesGreenTechnology = fields.Boolean(description='Set to true if this quote benefits from deduction on Green Technology.\r\nIf set to true the quote must have RotReducedInvoicingType set to normal and contain at least one row with applicable deduction.')
    VatAmount = fields.Number(dump_only=True)

    class Meta:
        unknown = INCLUDE



class QuoteConversionApi(Schema):
    Type = fields.Integer(description='0 = OrderDraft, 1 = Order', validate=[OneOf(choices=[0, 1], labels=[])])

    class Meta:
        unknown = INCLUDE



class QuoteRowApi(Schema):
    Amount = fields.Number(description='Returns a total amount of row. Format: 2 decimals')
    ArticleId = fields.UUID(description='Source: Get from /v2/articles')
    ArticleNumber = fields.String(dump_only=True)
    ContributionMargin = fields.Nested(lambda: ContributionMarginApi())
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    DiscountPercentage = fields.Number(description='Format: 4 decimals', validate=[Range(min=0, max=1, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    GreenTechnologyType = fields.Integer(description='Type of green technology on the quote row, can be : \r\nNone = 0,\r\nSolarCellInstallation = 1,\r\nElectricEnergyStorageInstallation = 2,\r\nElectricVehicleChargingPointInstallation = 3,\r\nDefault value is 0.', validate=[Range(min=0, max=3, min_inclusive=True, max_inclusive=True)])
    Id = fields.UUID(description='Unique Id provided by eAccounting for every row', dump_only=True)
    IsServiceArticle = fields.Boolean(description='IsServiceArticle = FALSE if the sales category for the article is of the type Goods\r\nIsServiceArticle = TRUE if the sales category for the article is of the type Service.', dump_only=True)
    IsTextRow = fields.Boolean(dump_only=True)
    IsVatFree = fields.Boolean(dump_only=True)
    IsWorkCost = fields.Boolean(dump_only=True)
    LineNumber = fields.Integer(dump_only=True)
    MaterialCosts = fields.Number(description='Only used for ROT/RUT.')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    Quantity = fields.Number(description='Format: 4 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,4})?'))])
    Text = fields.String(description="Max length: 2000 characters.\r\nDefault: For non text rows, default value will be the article's name; for text rows, there should be at least one character in place", validate=[Length(min=0, max=2000, equal=None)])
    UnitId = fields.UUID(description='Source: Get from /v2/units/{id}', dump_only=True)
    UnitPrice = fields.Number(description='Format: 2 decimals allowed if the customer and currency are domestic or 4 decimals if customer or currency is foreign')
    VatRate = fields.Number(description='Default: null\r\nPurpose: Provides VatRate value for the row.\r\nWhen row is a comment, value is null.', dump_only=True)
    WorkCostType = fields.Integer(description='0 = None, 1 = RotConstructionWork , 2 = RotElectricalWork , 3 = RotGlassSheetMetalWork , 4 = RotGroundWork , 5 = RotBrickWork , 6 = RotPaintDecorateWork , 7 = RotPlumbWork \r\n9 = RutCleanJobWork , 10 = RutCareClothTextile , 11 = RutCook , 12 = RutSnowRemove , 13 = RutGarden , 14 = RutBabySitt , 15 = RutOtherCare , 17 = RutHouseWorkHelp   \r\n18 = RutRemovalServices , 19 = RutITServices , 20 = RotHeatPump , 21 = RotHeatPump2 , 22 = RutHomeAppliances')
    WorkHours = fields.Number(description='Only used for ROT/RUT.')

    class Meta:
        unknown = INCLUDE



class RangeVariable(Schema):
    Kind = fields.Integer(dump_only=True)
    Name = fields.String(dump_only=True)
    TypeReference = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class RelatedAccounts(Schema):
    AccountNumber1 = fields.Integer()
    AccountNumber2 = fields.Integer()
    AccountNumber3 = fields.Integer()

    class Meta:
        unknown = INCLUDE



class SalesDocumentAttachmentApi(Schema):
    CreatedBy = fields.String(description='Full name of user who attached the file.')
    CreatedUtc = fields.AwareDateTime(description='Attachment date (UTC).')
    DocumentId = fields.UUID(description='Sales document ID.')
    DocumentSize = fields.Integer(description='Attached file size.')
    DocumentType = fields.Integer(description='Sales document type:\r\nCustomerInvoiceDraft = 1,\r\nCustomerInvoice = 2,\r\nQuote = 3,\r\nOrder = 4,\r\nPurchaseOrder = 5,\r\nQuoteDraft = 6', validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6], labels=[])])
    Id = fields.UUID(description='Attachment ID.')
    OriginalFilename = fields.String(description='Attached file name.')
    Thumbnail = fields.String(description="It is an image thumbnail, for PDF's Thumbnail = NULL.")

    class Meta:
        unknown = INCLUDE



class SalesDocumentAttachmentUploadApi(Schema):
    ContentType = fields.String(required=True, description="Required\r\n= ['application/pdf']", validate=[Length(min=0, max=15, equal=None)])
    Data = fields.String(description='Data or Url is required.\r\nFormat: Must be Base64 encoded byte array.')
    DockumentId = fields.UUID(required=True, description="Required\r\nDocument's id to which a sales document is beeing attached.")
    FileName = fields.String(required=True, description='Required\r\nThe file name that will be shown in UI.')
    Url = fields.String(description='Must be public URL')

    class Meta:
        unknown = INCLUDE



class SalesDocumentRotRutReductionPersonApi(Schema):
    Amount = fields.Number()
    Ssn = fields.String(description='Max length: 50 characters. Purpose: Social security number', validate=[Length(min=0, max=50, equal=None)])

    class Meta:
        unknown = INCLUDE



class SalesPriceListApi(Schema):
    ChangedUtc = fields.AwareDateTime()
    CurrencyCode = fields.String(description='Max length: 3 characters', validate=[Length(min=0, max=3, equal=None)])
    Id = fields.UUID(description='Unique Id provided by eAccounting of the sales price list', dump_only=True)
    IsActive = fields.Boolean()
    IsStandard = fields.Boolean(description='The standard price list is the list created by default by eAccounting when you are upgrading to Pro variant', dump_only=True)
    Name = fields.String()
    Note = fields.String()
    Number = fields.Integer()

    class Meta:
        unknown = INCLUDE



class SalesPriceListRowApi(Schema):
    ArticleId = fields.UUID(description='Purpose: Unique Id provided by eAccounting of article. Use /v2/articles.')
    ChangedUtc = fields.AwareDateTime(description='Purpose: Set when the sales price is changed manually')
    CurrencyCode = fields.String(description='Max length: 3 characters.', validate=[Length(min=0, max=3, equal=None)])
    GrossPrice = fields.Number()
    NetPrice = fields.Number()
    SalesPriceListId = fields.UUID(description='Purpose: Unique Id provided by eAccounting of the sales price list. Use /v2/salespricelists.')

    class Meta:
        unknown = INCLUDE



class SelectExpandClause(Schema):
    AllSelected = fields.Boolean(dump_only=True)
    SelectedItems = fields.List(fields.Nested(lambda: SelectItem()), dump_only=True)

    class Meta:
        unknown = INCLUDE



class SelectExpandQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    LevelsMaxLiteralExpansionDepth = fields.Integer()
    RawExpand = fields.String(dump_only=True)
    RawSelect = fields.String(dump_only=True)
    SelectExpandClause = fields.Nested(lambda: SelectExpandClause())
    Validator = fields.Nested(lambda: SelectExpandQueryValidator())

    class Meta:
        unknown = INCLUDE



class SelectExpandQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class SelectItem(Schema):

    class Meta:
        unknown = INCLUDE



class SingleValueNode(Schema):
    Kind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], labels=[])])
    TypeReference = fields.Nested(lambda: IEdmTypeReference())

    class Meta:
        unknown = INCLUDE



class SkipQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    RawValue = fields.String(dump_only=True)
    Validator = fields.Nested(lambda: SkipQueryValidator())
    Value = fields.Integer(dump_only=True)

    class Meta:
        unknown = INCLUDE



class SkipQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class StandardAccountApi(Schema):
    AccountNumber = fields.Integer()
    AccountType = fields.String()

    class Meta:
        unknown = INCLUDE



class SupplierApi(Schema):
    Address1 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    Address2 = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    AutomaticPaymentService = fields.Boolean(description='Purpose: Indicates if the supplier is paid by an automatic payment service. Supplier invoices to such suppliers will not be sent to the bank via the bank integration\r\nDefault value: false')
    BankAccountNumber = fields.String(description='Max length: 50 characters. Purpose: Only used in norwegian, dutch and danish eAccounting for domestic payments', validate=[Length(min=0, max=50, equal=None)])
    BankBban = fields.String(description='Purpose: Used on foreign payments to identify a bankaccount together with Bank Code (SupplierBankCode)\r\nFormat NO: 11 characters, Format DK: 11-14 characters', validate=[Length(min=0, max=50, equal=None), Regexp(regex=re.compile('^[a-zA-Z0-9]{1,35}$'))])
    BankBic = fields.String(description='Purpose: Used on foreign payments to identify a bankaccount together with IBAN (SupplierBankIban)\r\nFormat: 6 letters followed by 2 or 5 characters (total length 8 or 11)', validate=[Length(min=0, max=50, equal=None), Regexp(regex=re.compile('^[a-zA-Z]{6}([a-zA-z0-9]{2}|[a-zA-z0-9]{5})$'))])
    BankCode = fields.String(description='Purpose: Used on foreign payments to identify a bankaccount together with BBAN (SupplierBankBban)\r\nFormat: 2 letters followed by at least 3 characters', validate=[Length(min=0, max=50, equal=None), Regexp(regex=re.compile('^([a-zA-Z]{2})[a-zA-Z0-9]{3,}$'))])
    BankCountryCode = fields.String(description='Max length: 2 characters. Default value: Country of the supplier', validate=[Length(min=0, max=2, equal=None)])
    BankFeeCode = fields.Integer(description='Purpose: Used for foreign payments to determine which party that pays for aditional bank fees. 0 = None, 1 = SenderPaysAllBankCharges, 2 = ReceiverPaysAllBankCharges, 3 = ReceiverPaysForeignCosts', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])
    BankIban = fields.String(description='Purpose: Used on foreign payments to identify a bankaccount together with BIC (SupplierBankBic)\r\nFormat: 2 letters for country code, 2 control digits, 3 characters for bank identification', validate=[Length(min=0, max=50, equal=None), Regexp(regex=re.compile('^[a-zA-Z]{2}[0-9]{2}[a-zA-z0-9]{1,}$'))])
    BankName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    BankgiroNumber = fields.String(description='Max length: 10 characters. Purpose: Only used in swedish eAccounting, for swedish suppliers', validate=[Length(min=0, max=10, equal=None)])
    City = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    ContactPersonEmail = fields.String(description='Max length: 225 characters', validate=[Length(min=0, max=255, equal=None)])
    ContactPersonMobile = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    ContactPersonName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    ContactPersonPhone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    CorporateIdentityNumber = fields.String(description='Max length: 20 characters', validate=[Length(min=0, max=20, equal=None)])
    CountryCode = fields.String(validate=[Length(min=0, max=2, equal=None)])
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CurrencyCode = fields.String(description='Max length: 3 characters. Default value: Currency of the user company', validate=[Length(min=0, max=3, equal=None)])
    EmailAddress = fields.String(description='Max length: 225 characters', validate=[Length(min=0, max=255, equal=None)])
    ForeignPaymentCodeId = fields.UUID(description='Source: Get from /v2/foreignpaymentcodes. Purpose: Used for categorization of foreign purchases (NO and SE only). Must be set if having active bankintegration, Supplier is foreign and AutomaticPaymentService is false.')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    IsActive = fields.Boolean(description='Default: true')
    MessageThreads = fields.List(fields.UUID(), description='Fetch messages via GET /v2/messagethreads/{messageThreadId}', dump_only=True)
    MobilePhone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Name = fields.String(required=True, description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    Note = fields.String(description='Max length: 400 characters', validate=[Length(min=0, max=4000, equal=None)])
    Notes = fields.List(fields.UUID(), description='Fetch notes via GET /v2/notes/{noteId}', dump_only=True)
    PayFromBankAccountId = fields.UUID(description='Source: Get from /v2/bankaccounts. Purpose: Used for foreign payments to determine which bankaccount the payment will be from')
    PlusgiroNumber = fields.String(description='Max length: 10 characters. Purpose: Only used in swedish eAccounting, for swedish suppliers', validate=[Length(min=0, max=10, equal=None)])
    PostalCode = fields.String(description='Max length: 10 characters', validate=[Length(min=0, max=10, equal=None)])
    ProportionalVat = fields.Boolean(description='Purpose: Inform that the supplier has Proportional VAT activated Default: false')
    SelfEmployedWithoutFixedAddress = fields.Boolean()
    SupplierNumber = fields.String(description='Max length: 16 characters. Purpose: Unique identifier. If not provided, eAccounting will provide one', validate=[Length(min=0, max=16, equal=None)])
    Telephone = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    TermsOfPaymentId = fields.UUID(required=True, description='Source: Get from /v2/termsofpayment')
    UnpaidInvoicesAmount = fields.Number(default=0)
    UsesPaymentReferenceNumbers = fields.Boolean(description='Purpose: Used if the supplier uses payment reference numbers, OCR, KID etc. NO and SE only. Default: false')
    VatNumber = fields.String(description='Max length: 20 characters. Purpose: Only used in dutch eAccounting, used to check the VAT number before deducting the VAT (legislation) or for 3rd parties to validate supplier invoice information', validate=[Length(min=0, max=20, equal=None)])
    WwwAddress = fields.String(description='Max length: 255 characters', validate=[Length(min=0, max=255, equal=None)])

    class Meta:
        unknown = INCLUDE



class SupplierInvoiceApi(Schema):
    AllocationPeriods = fields.List(fields.Nested(lambda: AllocationPeriodApi()), description='Purpose: For create use POST /v2/allocationperiods', dump_only=True)
    Attachments = fields.List(fields.UUID())
    AutoCreditDebitPairing = fields.Boolean()
    BankAccountId = fields.UUID(dump_only=True)
    BankGiroNumber = fields.String(dump_only=True)
    CreatedFromDraftId = fields.UUID(dump_only=True)
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CurrencyCode = fields.String()
    CurrencyRate = fields.Number()
    DueDate = fields.AwareDateTime(description="Format: YYYY-MM-DD. Default: Date based on the supplier's terms of payment")
    Id = fields.UUID(description='Purpose: This is automatically generated by eAccounting upon creation', dump_only=True)
    InvoiceDate = fields.AwareDateTime(description='Format: YYYY-MM-DD')
    InvoiceNumber = fields.String(required=True)
    IsCreditInvoice = fields.Boolean()
    IsDomestic = fields.Boolean(dump_only=True)
    IsQuickInvoice = fields.Boolean(dump_only=True)
    Message = fields.String()
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    Number = fields.Integer(dump_only=True)
    NumberSeries = fields.String(dump_only=True)
    OcrNumber = fields.String()
    PaymentDate = fields.AwareDateTime(dump_only=True)
    PaymentFileStatus = fields.Integer(description='NoPaymentNecessary = 0, ReadyForAutomaticBankIntegration = 11, PaymentCreated = 12, PaymentReceivedByAutoPay = 13, PaymentSentToBank = 19, PaymentReceivedByBank = 20,\r\nReadyForManualPaymentFileExport = 21, ReadyForManualPaymentFileExportForeign = 22, ManualPaymentFileExported = 29, PaymentPaidInBank = 30, ReadyForDeferredAutomaticBankIntegration = 31,\r\nAwaitsSigning = 40, Signed = 41, PaymentRejectedByBank = 42, PaymentCancelledInBank = 43, PaymentCancelledInAutopay = 44, PaymentCancellationRequestSent = 45, FailedToSendToBank = 100', dump_only=True, validate=[OneOf(choices=[0, 11, 12, 13, 19, 20, 21, 22, 29, 30, 31, 40, 41, 42, 43, 44, 45, 100], labels=[])])
    PaymentStatus = fields.Integer(description='Unpaid = 3, PartiallyPaidOverDue = 4, PartiallyPaid = 5, Paid = 6, OverDue = 7, NotExportedToPaymentFile = 8,\r\nPaidInBank = 9, NotSentToBank = 10, AwaitingSigning = 11, CancellationRequestSentToBank = 12, PaymentCancelled = 13,\r\nRejectedPayment = 14, SentToBank = 15, ReceivedByBank = 16, PaymentExported = 17', dump_only=True, validate=[OneOf(choices=[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], labels=[])])
    PlusGiroNumber = fields.String(dump_only=True)
    RemainingAmount = fields.Number(dump_only=True)
    RemainingAmountInvoiceCurrency = fields.Number(dump_only=True)
    Rows = fields.List(fields.Nested(lambda: SupplierInvoiceRowApi()))
    SelfEmployedWithoutFixedAddress = fields.Boolean(dump_only=True)
    SetOffAmountInvoiceCurrency = fields.Number(dump_only=True)
    SkipSendToBank = fields.Boolean(description="Use when invoice is paid manually, won't be sent to the bank. Only has affect on active bank integration")
    Status = fields.Integer(description='0 = Draft, 1 = Normal, 2 = Deleted', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    SupplierId = fields.UUID(required=True, description='Source: Get from /v2/suppliers.')
    SupplierName = fields.String(dump_only=True)
    SupplierNumber = fields.String(dump_only=True)
    TotalAmount = fields.Number(required=True)
    Vat = fields.Number()
    VatHigh = fields.Number(description='Only for Norway')
    VatLow = fields.Number(description='Only for Norway')
    VatMedium = fields.Number(description='Only for Norway')
    VoucherId = fields.UUID(dump_only=True)
    VoucherNumber = fields.String(dump_only=True)

    class Meta:
        unknown = INCLUDE



class SupplierInvoiceApproverApi(Schema):
    ApproverId = fields.UUID(description='Source: Get from /v2/users')
    IsApproved = fields.Boolean(description='Represent if supplier invoice is approved by the approver')
    Name = fields.String(description='Full name of the approver')
    Priority = fields.Integer(description='Priority of the approver\r\nIf there are multiple approvers, the one with the lowest priority will be the first to approve\r\nPriority starts from 1\r\nIf priority = 0, then supplier invoice can be approved in any order.')

    class Meta:
        unknown = INCLUDE



class SupplierInvoiceDraftApi(Schema):
    AllocationPeriods = fields.List(fields.Nested(lambda: AllocationPeriodApi()), description='Purpose: For create use POST /v2/allocationperiods.', dump_only=True)
    ApprovalOrderType = fields.Integer(description='0 = Default, 1 = Can be approved in specific order, 2 = Can be approved in any order', dump_only=True, validate=[OneOf(choices=[0, 1, 2], labels=[])])
    ApprovalStatus = fields.Integer(description='Purpose: Use /v2/approval/supplierinvoice/{id}. 0 = None, 1 = Approved, 2 = Rejected, 3 = ReadyForApproval, 4 = ActionRequired', dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3, 4], labels=[])])
    Approvers = fields.List(fields.Nested(lambda: SupplierInvoiceApproverApi()), description='The list of approvers for the supplier invoice.\r\nIf ApprovalOrderType is set to 0(default), the list will be empty.', dump_only=True)
    Attachments = fields.Nested(lambda: AttachmentLinkApi())
    BankAccountId = fields.UUID(description='Source: Get from /v2/bankaccounts, if not provided the supplier bank account will be used.')
    CanBeApprovedByCurrentUser = fields.Boolean(description='If the user can approve the invoice in the approval flow', dump_only=True)
    CanBeBookeptByCurrentUser = fields.Boolean(description='If the user can bookkeep the invoice in the approval flow, approving the invoice will also bookkeep it', dump_only=True)
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    CurrencyCode = fields.String(description='Max length: 3 characters', validate=[Length(min=0, max=3, equal=None)])
    CurrencyRate = fields.Number(description="Purpose: If currency code is domestic and currency rate isn't included it will be fetched from eAccounting")
    DueDate = fields.AwareDateTime(description='Format: YYYY-MM-DD. Default: Date based on the suppliers Terms of payment')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    InvoiceDate = fields.AwareDateTime(description="Format: YYYY-MM-DD. Default: Today's date")
    InvoiceNumber = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    IsCreditInvoice = fields.Boolean(required=True)
    IsDomestic = fields.Boolean()
    IsQuickInvoice = fields.Boolean()
    Message = fields.String(description='Max length: 25 characters', validate=[Length(min=0, max=25, equal=None)])
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    OcrNumber = fields.String(description='Max length: 25 characters', validate=[Length(min=0, max=25, equal=None)])
    PaymentDate = fields.AwareDateTime(description='Format: YYYY-MM-DD')
    Rows = fields.List(fields.Nested(lambda: SupplierInvoiceDraftRowApi()), required=True)
    SelfEmployedWithoutFixedAddress = fields.Boolean()
    SkipSendToBank = fields.Boolean(description="Use when invoice is paid manually, won't be sent to the bank. Only has affect on active bank integration")
    SupplierId = fields.UUID(required=True, description='Source: Get from /v2/suppliers')
    SupplierInvoiceOrigin = fields.Integer(description='EAccounting = 0,\r\nAutoInvoice = 1,\r\nAPI = 2,\r\nVAT = 3')
    SupplierName = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    SupplierNumber = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    TotalAmount = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    Vat = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    VatHigh = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    VatLow = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    VatMedium = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class SupplierInvoiceDraftRowApi(Schema):
    AccountName = fields.String()
    AccountNumber = fields.Integer(validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DebitAmount = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting. This property will be updated on every change on the supplier invoice draft', dump_only=True)
    LineNumber = fields.Integer(description='Default: 1')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    ProportionalVatRateValue = fields.Integer(description='Only for Norway')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    TransactionText = fields.String()
    VatAmount = fields.Number(description='Only for Denmark and Netherlands')
    VatCodeId = fields.UUID(description='Purpose: Returns the Vat code id from the provided account number')
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class SupplierInvoiceRowApi(Schema):
    AccountName = fields.String(dump_only=True)
    AccountNumber = fields.Integer(validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters.')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters.')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters.')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DebetAmount = fields.Number(description='Format: Max 2 decimals', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    Id = fields.UUID(description='Purpose: This is automatically generated by eAccounting upon creation', dump_only=True)
    LineNumber = fields.Integer(dump_only=True)
    ProjectId = fields.UUID(description='Source: Get from /v2/projects.')
    ProportionalVatRateValue = fields.Integer(description='Only for Norway')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    TransactionText = fields.String()
    VatAmount = fields.Number(description='Only for Denmark and Netherlands')
    VatCodeId = fields.UUID(description='Only for Denmark and Netherlands')
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class TaxDeclarationDateApi(Schema):
    Day = fields.Integer(description='Range: 1 - 31', validate=[Range(min=1, max=31, min_inclusive=True, max_inclusive=True)])
    Month = fields.Integer(description='Range: 1 - 12', validate=[Range(min=1, max=12, min_inclusive=True, max_inclusive=True)])

    class Meta:
        unknown = INCLUDE



class TermsOfPayment(Schema):
    AvailableForPurchase = fields.Boolean(allow_none=True)
    AvailableForSales = fields.Boolean(allow_none=True)
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', load_only=True)
    Name = fields.String()
    NameEnglish = fields.String()
    NumberOfDays = fields.Integer()
    TermsOfPaymentTypeId = fields.Integer(description='0 = Normal, 1 = CurrentMonth, 2 = Cash, 3 = CardPayment, 4 = DigitalWallet, 5 = PaymentServiceProvider')
    TermsOfPaymentTypeText = fields.String(allow_none=True)

    class Meta:
        endpoint = '/termsofpayments'
        allowed_methods = ['list', 'get']
        envelopes = {'list': {'class': PaginatedResponse, 'data_attr': 'Data'}}


class TopQueryOption(Schema):
    Context = fields.Nested(lambda: ODataQueryContext())
    RawValue = fields.String(dump_only=True)
    Validator = fields.Nested(lambda: TopQueryValidator())
    Value = fields.Integer(dump_only=True)

    class Meta:
        unknown = INCLUDE



class TopQueryValidator(Schema):

    class Meta:
        unknown = INCLUDE



class TransformationNode(Schema):
    Kind = fields.Integer(dump_only=True, validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])

    class Meta:
        unknown = INCLUDE



class UnitApi(Schema):
    Abbreviation = fields.String()
    AbbreviationEnglish = fields.String()
    Code = fields.String()
    Id = fields.UUID()
    Name = fields.String()

    class Meta:
        unknown = INCLUDE



class UserApi(Schema):
    Email = fields.String()
    FirstName = fields.String()
    Id = fields.UUID()
    IsActive = fields.Boolean()
    IsConsultant = fields.Boolean()
    IsCurrentUser = fields.Boolean()
    LastName = fields.String()

    class Meta:
        unknown = INCLUDE



class VatCodeApi(Schema):
    Code = fields.String()
    Description = fields.String()
    Id = fields.UUID()
    OssCodeType = fields.Integer(description='0 = None, 1 = Sales, 2 = Vat', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    RelatedAccounts = fields.Nested(lambda: RelatedAccounts())
    VatRate = fields.Number()

    class Meta:
        unknown = INCLUDE



class VatCodeRateApi(Schema):
    Code = fields.String()
    Description = fields.String()
    Id = fields.UUID()
    OssCodeType = fields.Integer(description='0 = None, 1 = Sales, 2 = Vat', validate=[OneOf(choices=[0, 1, 2], labels=[])])
    RelatedAccounts = fields.Nested(lambda: RelatedAccounts())
    VatRates = fields.List(fields.Nested(lambda: VatRateApi()))

    class Meta:
        unknown = INCLUDE



class VatRateApi(Schema):
    VatRate = fields.Number()
    VatRateDate = fields.AwareDateTime()

    class Meta:
        unknown = INCLUDE



class VatReportApi(Schema):
    ApprovalEventsHistory = fields.List(fields.Nested(lambda: DocumentApprovalEventApi()), description='The history of approval events of the vat report.')
    CreatedUtc = fields.AwareDateTime()
    DocumentApprovalStatus = fields.Integer(description='0 = None, 1 = Approved, 2 = Rejected, 3 = ReadyForApproval', validate=[OneOf(choices=[0, 1, 2, 3], labels=[])])
    DocumentId = fields.UUID(description='Purpose: Fetch the associated document. Can be null if the vat report does not have an associated file created. Use GET /v2/documents/{id}')
    EndDate = fields.AwareDateTime()
    Id = fields.UUID()
    IsRegretted = fields.Boolean(description='Indicates whether the vat report was undone')
    ModifiedUtc = fields.AwareDateTime()
    Name = fields.String()
    RegrettedByUserId = fields.UUID(description='Purpose: If the vat report was undone this indicates the user id that did the action. Can be null if not undone. Use GET /v2/users')
    RegrettedDate = fields.AwareDateTime(description='Purpose: If the vat report was undone this indicates the date of the action. Can be null if not undone')
    SentForApprovalByUserId = fields.UUID(description='Purpose: If the vat report was sent for approval this indicates the user id that did the action. Can be null if not sent for approval. Use GET /v2/users')
    StartDate = fields.AwareDateTime()
    TotalAmount = fields.Number(description='Predicted vat amount to pay or be refunded')
    VoucherId = fields.UUID(description='Purpose: Fetch the associated voucher. Can be null if there is no associated voucher. Use GET /v2/vouchers/{fiscalyearId}/{voucherId}')

    class Meta:
        unknown = INCLUDE



class VoucherApi(Schema):
    Attachments = fields.Nested(lambda: AttachmentLinkApi())
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    ImportedVoucherNumber = fields.String(description='Purpose: Returns original voucher number if the voucher is imported from another system.', dump_only=True)
    ModifiedUtc = fields.AwareDateTime()
    NumberAndNumberSeries = fields.String(description='Purpose: Returns the voucher number.', dump_only=True)
    NumberSeries = fields.String(description='Purpose: Returns the number series. Use parameter useDefaultVoucherSeries with false value to set Series.')
    Rows = fields.List(fields.Nested(lambda: VoucherRowApi()), required=True)
    SourceId = fields.UUID(dump_only=True)
    VoucherDate = fields.AwareDateTime(required=True, description='Format: yyyy-mm-dd')
    VoucherText = fields.String(required=True, description='Max length: 1000 characters', validate=[Length(min=0, max=1000, equal=None)])
    VoucherType = fields.Integer(description='2 = ManualVoucher, 5 = BankAccountTransferDeposit, 6 = BankAccountTransferWithDrawal, \r\n7 = PurchaseReceipt, 8 = VatReport, 9 = SieImport, 10 = BankTransactionDeposit, 11 = BankTransactionWithdrawal,\r\n12 = SupplierInvoiceDebit, 13 = SupplierInvoiceCredit, 14 = CustomerInvoiceDebit, 15 = CustomerInvoiceCredit,\r\n16 = ClaimOnCardAcquirer, 17 = TaxReturn, 18 = AllocationPeriod, 19 = AllocationPeriodCorrection, \r\n20 = InventoryEvent, 21 = EmployerReport, 22 = Payslip, 23 = CustomerQuickInvoiceDebit,\r\n24 = CustomerQuickInvoiceCredit, 25 = SupplierQuickInvoiceDebit, 26 = SupplierQuickInvoiceCredit, \r\n27 = IZettleVoucher', validate=[OneOf(choices=[2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], labels=[])])

    class Meta:
        unknown = INCLUDE



class VoucherDraftApi(Schema):
    CreatedUtc = fields.AwareDateTime(dump_only=True)
    Id = fields.UUID(description='Purpose: Unique Id provided by eAccounting', dump_only=True)
    ModifiedUtc = fields.AwareDateTime(dump_only=True)
    NumberSeries = fields.String(description='Purpose: Returns the number series. If not set, will be used the default number series.')
    Rows = fields.List(fields.Nested(lambda: VoucherDraftRowApi()))
    VoucherDate = fields.AwareDateTime(required=True, description='Format: yyyy-mm-dd')
    VoucherText = fields.String(description='Description. Max length: 1000 characters', validate=[Length(min=0, max=1000, equal=None)])

    class Meta:
        unknown = INCLUDE



class VoucherDraftRowApi(Schema):
    AccountNumber = fields.Integer(required=True, validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DebitAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    TransactionText = fields.String(description='Max length: 50 characters', validate=[Length(min=0, max=50, equal=None)])
    VatCodeId = fields.UUID(description='Purpose: Returns vat code id. If is set, is used to calculate the correspondent vat amount.')
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class VoucherRowApi(Schema):
    AccountDescription = fields.String(dump_only=True)
    AccountNumber = fields.Integer(required=True, validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=None, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DebitAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=None, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    TransactionText = fields.String(description='Max length: 60 characters', validate=[Length(min=0, max=60, equal=None)])
    VatAmount = fields.Number()
    VatCodeAndPercent = fields.String()
    VatCodeId = fields.UUID()
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class VoucherWithOverunderPaymentApi(Schema):
    Attachments = fields.Nested(lambda: AttachmentLinkApi())
    Rows = fields.List(fields.Nested(lambda: VoucherWithOverunderPaymentRowApi()), required=True)
    VoucherDate = fields.AwareDateTime(required=True, description='Format: yyyy-mm-dd')
    VoucherText = fields.String(description='Default: Default text for payment from customer or supplier', validate=[Length(min=0, max=1000, equal=None)])

    class Meta:
        unknown = INCLUDE



class VoucherWithOverunderPaymentRowApi(Schema):
    AccountNumber = fields.Integer(required=True, validate=[Range(min=1, max=None, min_inclusive=True, max_inclusive=True)])
    CostCenterItemId1 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId2 = fields.UUID(description='Source: Get from /v2/costcenters')
    CostCenterItemId3 = fields.UUID(description='Source: Get from /v2/costcenters')
    CreditAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    CustomerId = fields.UUID()
    DebitAmount = fields.Number(description='Format: Max 2 decimals', validate=[Range(min=0, max=1000000000, min_inclusive=True, max_inclusive=True), Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    DeliveryDate = fields.AwareDateTime(description='Format: YYYY-MM-DD\r\nPurpose: This feature is for dutch companies only which enabled agriculture support')
    HarvestYear = fields.Integer(description='Purpose: This feature is for dutch companies only which enabled agriculture support')
    ProjectId = fields.UUID(description='Source: Get from /v2/projects')
    Quantity = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])
    SupplierId = fields.UUID()
    VatCodeId = fields.UUID()
    Weight = fields.Number(description='Format: Max 2 decimals\r\nPurpose: This feature is for dutch companies only which enabled agriculture support', validate=[Regexp(regex=re.compile('[-]?\\d+(.\\d{1,2})?'))])

    class Meta:
        unknown = INCLUDE



class WebshopOrderApi(Schema):
    BaseCurrencyCode = fields.String()
    CustomerIsPrivatePerson = fields.Boolean()
    Id = fields.UUID()
    Name = fields.String()
    Note = fields.String()
    Number = fields.String()
    OrderCurrencyCode = fields.String()
    OrderDate = fields.AwareDateTime()
    OrderNumber = fields.String()
    Rows = fields.List(fields.Nested(lambda: WebshopOrderRowApi()))
    TotalAmountBaseCurrency = fields.Number()
    TotalAmountOrderCurrency = fields.Number()

    class Meta:
        unknown = INCLUDE



class WebshopOrderRowApi(Schema):
    ArticleName = fields.String()
    ArticleNumber = fields.String()
    Id = fields.UUID()
    PercentVat = fields.Number()
    PricePerUnitInvoiceCurrency = fields.Number()
    Quantity = fields.Number()
    Sum = fields.Number()
    UnitAbbreviation = fields.String()

    class Meta:
        unknown = INCLUDE
